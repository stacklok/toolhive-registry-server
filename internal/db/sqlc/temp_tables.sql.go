// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: temp_tables.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
)

const createTempIconTable = `-- name: CreateTempIconTable :exec

CREATE TEMP TABLE temp_mcp_server_icon ON COMMIT DROP AS
SELECT server_id, source_uri, mime_type, theme FROM mcp_server_icon
  WITH NO DATA
`

// Temp Icon Table Operations
func (q *Queries) CreateTempIconTable(ctx context.Context) error {
	_, err := q.db.Exec(ctx, createTempIconTable)
	return err
}

const createTempPackageTable = `-- name: CreateTempPackageTable :exec

CREATE TEMP TABLE temp_mcp_server_package ON COMMIT DROP AS
SELECT server_id, registry_type, pkg_registry_url, pkg_identifier, pkg_version, runtime_hint, runtime_arguments, package_arguments, sha256_hash, transport, transport_url, env_vars, transport_headers FROM mcp_server_package
  WITH NO DATA
`

// Temp Package Table Operations
func (q *Queries) CreateTempPackageTable(ctx context.Context) error {
	_, err := q.db.Exec(ctx, createTempPackageTable)
	return err
}

const createTempRemoteTable = `-- name: CreateTempRemoteTable :exec

CREATE TEMP TABLE temp_mcp_server_remote ON COMMIT DROP AS
SELECT server_id, transport, transport_url, transport_headers FROM mcp_server_remote
  WITH NO DATA
`

// Temp Remote Table Operations
func (q *Queries) CreateTempRemoteTable(ctx context.Context) error {
	_, err := q.db.Exec(ctx, createTempRemoteTable)
	return err
}

const createTempServerTable = `-- name: CreateTempServerTable :exec


CREATE TEMP TABLE temp_mcp_server ON COMMIT DROP AS
SELECT id, name, version, reg_id, created_at, updated_at, description, title, website, upstream_meta, server_meta, repository_url, repository_id, repository_subfolder, repository_type FROM mcp_server
  WITH NO DATA
`

// Temporary table operations for bulk sync
// Note: These queries reference temp tables that don't exist in the schema.
// sqlc cannot validate these, but we organize them here for maintainability.
// Temp Server Table Operations
func (q *Queries) CreateTempServerTable(ctx context.Context) error {
	_, err := q.db.Exec(ctx, createTempServerTable)
	return err
}

const deleteOrphanedIcons = `-- name: DeleteOrphanedIcons :exec
DELETE FROM mcp_server_icon
WHERE server_id = ANY($1::UUID[])
  AND (server_id, source_uri, mime_type, theme) NOT IN (
    SELECT server_id, source_uri, mime_type, theme FROM temp_mcp_server_icon
  )
`

func (q *Queries) DeleteOrphanedIcons(ctx context.Context, serverIds []uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteOrphanedIcons, serverIds)
	return err
}

const deleteOrphanedPackages = `-- name: DeleteOrphanedPackages :exec
DELETE FROM mcp_server_package
WHERE server_id = ANY($1::UUID[])
  AND (server_id, pkg_identifier, transport) NOT IN (
    SELECT server_id, pkg_identifier, transport FROM temp_mcp_server_package
  )
`

func (q *Queries) DeleteOrphanedPackages(ctx context.Context, serverIds []uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteOrphanedPackages, serverIds)
	return err
}

const deleteOrphanedRemotes = `-- name: DeleteOrphanedRemotes :exec
DELETE FROM mcp_server_remote
WHERE server_id = ANY($1::UUID[])
  AND (server_id, transport, transport_url) NOT IN (
    SELECT server_id, transport, transport_url FROM temp_mcp_server_remote
  )
`

func (q *Queries) DeleteOrphanedRemotes(ctx context.Context, serverIds []uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteOrphanedRemotes, serverIds)
	return err
}

const upsertIconsFromTemp = `-- name: UpsertIconsFromTemp :exec
INSERT INTO mcp_server_icon (server_id, source_uri, mime_type, theme)
SELECT server_id, source_uri, mime_type, theme::icon_theme
FROM temp_mcp_server_icon
ON CONFLICT (server_id, source_uri, mime_type, theme)
DO NOTHING
`

func (q *Queries) UpsertIconsFromTemp(ctx context.Context) error {
	_, err := q.db.Exec(ctx, upsertIconsFromTemp)
	return err
}

const upsertPackagesFromTemp = `-- name: UpsertPackagesFromTemp :exec
INSERT INTO mcp_server_package (
    server_id, registry_type, pkg_registry_url, pkg_identifier, pkg_version,
    runtime_hint, runtime_arguments, package_arguments, env_vars, sha256_hash,
    transport, transport_url, transport_headers
)
SELECT
    server_id, registry_type, pkg_registry_url, pkg_identifier, pkg_version,
    runtime_hint, runtime_arguments, package_arguments, env_vars, sha256_hash,
    transport, transport_url, transport_headers
FROM temp_mcp_server_package
ON CONFLICT (server_id, pkg_identifier, transport)
DO UPDATE SET
    registry_type = EXCLUDED.registry_type,
    pkg_registry_url = EXCLUDED.pkg_registry_url,
    pkg_version = EXCLUDED.pkg_version,
    runtime_hint = EXCLUDED.runtime_hint,
    runtime_arguments = EXCLUDED.runtime_arguments,
    package_arguments = EXCLUDED.package_arguments,
    env_vars = EXCLUDED.env_vars,
    sha256_hash = EXCLUDED.sha256_hash,
    transport_url = EXCLUDED.transport_url,
    transport_headers = EXCLUDED.transport_headers
`

func (q *Queries) UpsertPackagesFromTemp(ctx context.Context) error {
	_, err := q.db.Exec(ctx, upsertPackagesFromTemp)
	return err
}

const upsertRemotesFromTemp = `-- name: UpsertRemotesFromTemp :exec
INSERT INTO mcp_server_remote (server_id, transport, transport_url, transport_headers)
SELECT server_id, transport, transport_url, transport_headers
FROM temp_mcp_server_remote
ON CONFLICT (server_id, transport, transport_url)
DO UPDATE SET transport_headers = EXCLUDED.transport_headers
`

func (q *Queries) UpsertRemotesFromTemp(ctx context.Context) error {
	_, err := q.db.Exec(ctx, upsertRemotesFromTemp)
	return err
}

const upsertServersFromTemp = `-- name: UpsertServersFromTemp :exec
INSERT INTO mcp_server (
    name, version, reg_id, created_at, updated_at,
    description, title, website, upstream_meta, server_meta,
    repository_url, repository_id, repository_subfolder, repository_type
)
SELECT
    name, version, reg_id, created_at, updated_at,
    description, title, website, upstream_meta, server_meta,
    repository_url, repository_id, repository_subfolder, repository_type
FROM temp_mcp_server
ON CONFLICT (reg_id, name, version)
DO UPDATE SET
    updated_at = EXCLUDED.updated_at,
    description = EXCLUDED.description,
    title = EXCLUDED.title,
    website = EXCLUDED.website,
    upstream_meta = EXCLUDED.upstream_meta,
    server_meta = EXCLUDED.server_meta,
    repository_url = EXCLUDED.repository_url,
    repository_id = EXCLUDED.repository_id,
    repository_subfolder = EXCLUDED.repository_subfolder,
    repository_type = EXCLUDED.repository_type
`

func (q *Queries) UpsertServersFromTemp(ctx context.Context) error {
	_, err := q.db.Exec(ctx, upsertServersFromTemp)
	return err
}
