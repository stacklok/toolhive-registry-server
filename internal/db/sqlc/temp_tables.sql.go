// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: temp_tables.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
)

const createTempIconTable = `-- name: CreateTempIconTable :exec

CREATE TEMP TABLE temp_mcp_server_icon ON COMMIT DROP AS
SELECT entry_id, source_uri, mime_type, theme FROM mcp_server_icon
  WITH NO DATA
`

// Temp Icon Table Operations
func (q *Queries) CreateTempIconTable(ctx context.Context) error {
	_, err := q.db.Exec(ctx, createTempIconTable)
	return err
}

const createTempPackageTable = `-- name: CreateTempPackageTable :exec

CREATE TEMP TABLE temp_mcp_server_package ON COMMIT DROP AS
SELECT entry_id, registry_type, pkg_registry_url, pkg_identifier, pkg_version, runtime_hint, runtime_arguments, package_arguments, sha256_hash, transport, transport_url, env_vars, transport_headers FROM mcp_server_package
  WITH NO DATA
`

// Temp Package Table Operations
func (q *Queries) CreateTempPackageTable(ctx context.Context) error {
	_, err := q.db.Exec(ctx, createTempPackageTable)
	return err
}

const createTempRegistryEntryTable = `-- name: CreateTempRegistryEntryTable :exec


CREATE TEMP TABLE temp_registry_entry ON COMMIT DROP AS
SELECT id, reg_id, entry_type, name, title, description, version, created_at, updated_at FROM registry_entry
  WITH NO DATA
`

// Temporary table operations for bulk sync
// Note: These queries reference temp tables that don't exist in the schema.
// sqlc cannot validate these, but we organize them here for maintainability.
// Temp Server Table Operations
func (q *Queries) CreateTempRegistryEntryTable(ctx context.Context) error {
	_, err := q.db.Exec(ctx, createTempRegistryEntryTable)
	return err
}

const createTempRemoteTable = `-- name: CreateTempRemoteTable :exec

CREATE TEMP TABLE temp_mcp_server_remote ON COMMIT DROP AS
SELECT entry_id, transport, transport_url, transport_headers FROM mcp_server_remote
  WITH NO DATA
`

// Temp Remote Table Operations
func (q *Queries) CreateTempRemoteTable(ctx context.Context) error {
	_, err := q.db.Exec(ctx, createTempRemoteTable)
	return err
}

const createTempServerTable = `-- name: CreateTempServerTable :exec
CREATE TEMP TABLE temp_mcp_server ON COMMIT DROP AS
SELECT website, upstream_meta, server_meta, repository_url, repository_id, repository_subfolder, repository_type, entry_id FROM mcp_server
  WITH NO DATA
`

func (q *Queries) CreateTempServerTable(ctx context.Context) error {
	_, err := q.db.Exec(ctx, createTempServerTable)
	return err
}

const createTempSkillTable = `-- name: CreateTempSkillTable :exec

CREATE TEMP TABLE temp_skill ON COMMIT DROP AS
SELECT entry_id, namespace, status, license, compatibility, allowed_tools, repository, icons, metadata, extension_meta FROM skill
  WITH NO DATA
`

// Temp Skill Table Operations
func (q *Queries) CreateTempSkillTable(ctx context.Context) error {
	_, err := q.db.Exec(ctx, createTempSkillTable)
	return err
}

const deleteOrphanedIcons = `-- name: DeleteOrphanedIcons :exec
DELETE FROM mcp_server_icon
WHERE entry_id = ANY($1::UUID[])
  AND (entry_id, source_uri, mime_type, theme) NOT IN (
    SELECT entry_id, source_uri, mime_type, theme FROM temp_mcp_server_icon
  )
`

func (q *Queries) DeleteOrphanedIcons(ctx context.Context, entryIds []uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteOrphanedIcons, entryIds)
	return err
}

const deleteOrphanedPackages = `-- name: DeleteOrphanedPackages :exec
DELETE FROM mcp_server_package
WHERE entry_id = ANY($1::UUID[])
  AND (entry_id, pkg_identifier, transport) NOT IN (
    SELECT entry_id, pkg_identifier, transport FROM temp_mcp_server_package
  )
`

func (q *Queries) DeleteOrphanedPackages(ctx context.Context, entryIds []uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteOrphanedPackages, entryIds)
	return err
}

const deleteOrphanedRemotes = `-- name: DeleteOrphanedRemotes :exec
DELETE FROM mcp_server_remote
WHERE entry_id = ANY($1::UUID[])
  AND (entry_id, transport, transport_url) NOT IN (
    SELECT entry_id, transport, transport_url FROM temp_mcp_server_remote
  )
`

func (q *Queries) DeleteOrphanedRemotes(ctx context.Context, entryIds []uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteOrphanedRemotes, entryIds)
	return err
}

const upsertIconsFromTemp = `-- name: UpsertIconsFromTemp :exec
INSERT INTO mcp_server_icon (entry_id, source_uri, mime_type, theme)
SELECT entry_id, source_uri, mime_type, theme::icon_theme
FROM temp_mcp_server_icon
ON CONFLICT (entry_id, source_uri, mime_type, theme)
DO NOTHING
`

func (q *Queries) UpsertIconsFromTemp(ctx context.Context) error {
	_, err := q.db.Exec(ctx, upsertIconsFromTemp)
	return err
}

const upsertPackagesFromTemp = `-- name: UpsertPackagesFromTemp :exec
INSERT INTO mcp_server_package (
    entry_id, registry_type, pkg_registry_url, pkg_identifier, pkg_version,
    runtime_hint, runtime_arguments, package_arguments, env_vars, sha256_hash,
    transport, transport_url, transport_headers
)
SELECT
    entry_id, registry_type, pkg_registry_url, pkg_identifier, pkg_version,
    runtime_hint, runtime_arguments, package_arguments, env_vars, sha256_hash,
    transport, transport_url, transport_headers
FROM temp_mcp_server_package
ON CONFLICT (entry_id, registry_type, pkg_identifier, transport)
DO UPDATE SET
    pkg_registry_url = EXCLUDED.pkg_registry_url,
    pkg_version = EXCLUDED.pkg_version,
    runtime_hint = EXCLUDED.runtime_hint,
    runtime_arguments = EXCLUDED.runtime_arguments,
    package_arguments = EXCLUDED.package_arguments,
    env_vars = EXCLUDED.env_vars,
    sha256_hash = EXCLUDED.sha256_hash,
    transport_url = EXCLUDED.transport_url,
    transport_headers = EXCLUDED.transport_headers
`

func (q *Queries) UpsertPackagesFromTemp(ctx context.Context) error {
	_, err := q.db.Exec(ctx, upsertPackagesFromTemp)
	return err
}

const upsertRegistryEntriesFromTemp = `-- name: UpsertRegistryEntriesFromTemp :many
INSERT INTO registry_entry (
    id, reg_id, entry_type, name, title, description, version, created_at, updated_at
)
SELECT id,
       reg_id,
       entry_type,
       name,
       title,
       description,
       version,
       created_at,
       updated_at
  FROM temp_registry_entry
    ON CONFLICT (reg_id, name, version)
    DO UPDATE SET
      entry_type = EXCLUDED.entry_type,
      title = EXCLUDED.title,
      description = EXCLUDED.description,
      updated_at = EXCLUDED.updated_at
RETURNING id, reg_id, entry_type, name, version
`

type UpsertRegistryEntriesFromTempRow struct {
	ID        uuid.UUID `json:"id"`
	RegID     uuid.UUID `json:"reg_id"`
	EntryType EntryType `json:"entry_type"`
	Name      string    `json:"name"`
	Version   string    `json:"version"`
}

func (q *Queries) UpsertRegistryEntriesFromTemp(ctx context.Context) ([]UpsertRegistryEntriesFromTempRow, error) {
	rows, err := q.db.Query(ctx, upsertRegistryEntriesFromTemp)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UpsertRegistryEntriesFromTempRow{}
	for rows.Next() {
		var i UpsertRegistryEntriesFromTempRow
		if err := rows.Scan(
			&i.ID,
			&i.RegID,
			&i.EntryType,
			&i.Name,
			&i.Version,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertRemotesFromTemp = `-- name: UpsertRemotesFromTemp :exec
INSERT INTO mcp_server_remote (entry_id, transport, transport_url, transport_headers)
SELECT entry_id, transport, transport_url, transport_headers
FROM temp_mcp_server_remote
ON CONFLICT (entry_id, transport, transport_url)
DO UPDATE SET transport_headers = EXCLUDED.transport_headers
`

func (q *Queries) UpsertRemotesFromTemp(ctx context.Context) error {
	_, err := q.db.Exec(ctx, upsertRemotesFromTemp)
	return err
}

const upsertServersFromTemp = `-- name: UpsertServersFromTemp :exec
INSERT INTO mcp_server (
    entry_id, website, upstream_meta, server_meta,
    repository_url, repository_id, repository_subfolder, repository_type
)
SELECT entry_id,
       website,
       upstream_meta,
       server_meta,
       repository_url,
       repository_id,
       repository_subfolder,
       repository_type
FROM temp_mcp_server
  ON CONFLICT (entry_id)
  DO UPDATE SET
    website = EXCLUDED.website,
    upstream_meta = EXCLUDED.upstream_meta,
    server_meta = EXCLUDED.server_meta,
    repository_url = EXCLUDED.repository_url,
    repository_id = EXCLUDED.repository_id,
    repository_subfolder = EXCLUDED.repository_subfolder,
    repository_type = EXCLUDED.repository_type
`

func (q *Queries) UpsertServersFromTemp(ctx context.Context) error {
	_, err := q.db.Exec(ctx, upsertServersFromTemp)
	return err
}

const upsertSkillsFromTemp = `-- name: UpsertSkillsFromTemp :exec
INSERT INTO skill (
    entry_id, namespace, status, license, compatibility,
    allowed_tools, repository, icons, metadata, extension_meta
)
SELECT entry_id, namespace, status, license, compatibility,
       allowed_tools, repository, icons, metadata, extension_meta
FROM temp_skill
ON CONFLICT (entry_id)
DO UPDATE SET
    namespace = EXCLUDED.namespace,
    status = EXCLUDED.status,
    license = EXCLUDED.license,
    compatibility = EXCLUDED.compatibility,
    allowed_tools = EXCLUDED.allowed_tools,
    repository = EXCLUDED.repository,
    icons = EXCLUDED.icons,
    metadata = EXCLUDED.metadata,
    extension_meta = EXCLUDED.extension_meta
`

func (q *Queries) UpsertSkillsFromTemp(ctx context.Context) error {
	_, err := q.db.Exec(ctx, upsertSkillsFromTemp)
	return err
}
