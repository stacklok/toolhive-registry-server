// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: servers.sql

package sqlc

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const deleteServerVersion = `-- name: DeleteServerVersion :execrows
DELETE FROM mcp_server
WHERE reg_id = $1
  AND name = $2
  AND version = $3
`

type DeleteServerVersionParams struct {
	RegID   uuid.UUID `json:"reg_id"`
	Name    string    `json:"name"`
	Version string    `json:"version"`
}

func (q *Queries) DeleteServerVersion(ctx context.Context, arg DeleteServerVersionParams) (int64, error) {
	result, err := q.db.Exec(ctx, deleteServerVersion, arg.RegID, arg.Name, arg.Version)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getServerVersion = `-- name: GetServerVersion :one
SELECT r.reg_type as registry_type,
       s.id,
       s.name,
       s.version,
       (l.latest_server_id IS NOT NULL)::boolean AS is_latest,
       s.created_at,
       s.updated_at,
       s.description,
       s.title,
       s.website,
       s.upstream_meta,
       s.server_meta,
       s.repository_url,
       s.repository_id,
       s.repository_subfolder,
       s.repository_type
  FROM mcp_server s
  JOIN registry r ON s.reg_id = r.id
  LEFT JOIN latest_server_version l ON s.id = l.latest_server_id
 WHERE s.name = $1
   AND s.version = $2
   AND ($3::text IS NULL OR r.name = $3::text)
`

type GetServerVersionParams struct {
	Name         string  `json:"name"`
	Version      string  `json:"version"`
	RegistryName *string `json:"registry_name"`
}

type GetServerVersionRow struct {
	RegistryType        RegistryType `json:"registry_type"`
	ID                  uuid.UUID    `json:"id"`
	Name                string       `json:"name"`
	Version             string       `json:"version"`
	IsLatest            bool         `json:"is_latest"`
	CreatedAt           *time.Time   `json:"created_at"`
	UpdatedAt           *time.Time   `json:"updated_at"`
	Description         *string      `json:"description"`
	Title               *string      `json:"title"`
	Website             *string      `json:"website"`
	UpstreamMeta        []byte       `json:"upstream_meta"`
	ServerMeta          []byte       `json:"server_meta"`
	RepositoryUrl       *string      `json:"repository_url"`
	RepositoryID        *string      `json:"repository_id"`
	RepositorySubfolder *string      `json:"repository_subfolder"`
	RepositoryType      *string      `json:"repository_type"`
}

func (q *Queries) GetServerVersion(ctx context.Context, arg GetServerVersionParams) (GetServerVersionRow, error) {
	row := q.db.QueryRow(ctx, getServerVersion, arg.Name, arg.Version, arg.RegistryName)
	var i GetServerVersionRow
	err := row.Scan(
		&i.RegistryType,
		&i.ID,
		&i.Name,
		&i.Version,
		&i.IsLatest,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Description,
		&i.Title,
		&i.Website,
		&i.UpstreamMeta,
		&i.ServerMeta,
		&i.RepositoryUrl,
		&i.RepositoryID,
		&i.RepositorySubfolder,
		&i.RepositoryType,
	)
	return i, err
}

const insertServerIcon = `-- name: InsertServerIcon :exec
INSERT INTO mcp_server_icon (
    server_id,
    source_uri,
    mime_type,
    theme
) VALUES (
    $1,
    $2,
    $3,
    $4
)
`

type InsertServerIconParams struct {
	ServerID  uuid.UUID `json:"server_id"`
	SourceUri string    `json:"source_uri"`
	MimeType  string    `json:"mime_type"`
	Theme     IconTheme `json:"theme"`
}

func (q *Queries) InsertServerIcon(ctx context.Context, arg InsertServerIconParams) error {
	_, err := q.db.Exec(ctx, insertServerIcon,
		arg.ServerID,
		arg.SourceUri,
		arg.MimeType,
		arg.Theme,
	)
	return err
}

const insertServerPackage = `-- name: InsertServerPackage :exec
INSERT INTO mcp_server_package (
    server_id,
    registry_type,
    pkg_registry_url,
    pkg_identifier,
    pkg_version,
    runtime_hint,
    runtime_arguments,
    package_arguments,
    env_vars,
    sha256_hash,
    transport,
    transport_url,
    transport_headers
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10,
    $11,
    $12,
    $13
)
`

type InsertServerPackageParams struct {
	ServerID         uuid.UUID `json:"server_id"`
	RegistryType     string    `json:"registry_type"`
	PkgRegistryUrl   string    `json:"pkg_registry_url"`
	PkgIdentifier    string    `json:"pkg_identifier"`
	PkgVersion       string    `json:"pkg_version"`
	RuntimeHint      *string   `json:"runtime_hint"`
	RuntimeArguments []string  `json:"runtime_arguments"`
	PackageArguments []string  `json:"package_arguments"`
	EnvVars          []string  `json:"env_vars"`
	Sha256Hash       *string   `json:"sha256_hash"`
	Transport        string    `json:"transport"`
	TransportUrl     *string   `json:"transport_url"`
	TransportHeaders []string  `json:"transport_headers"`
}

func (q *Queries) InsertServerPackage(ctx context.Context, arg InsertServerPackageParams) error {
	_, err := q.db.Exec(ctx, insertServerPackage,
		arg.ServerID,
		arg.RegistryType,
		arg.PkgRegistryUrl,
		arg.PkgIdentifier,
		arg.PkgVersion,
		arg.RuntimeHint,
		arg.RuntimeArguments,
		arg.PackageArguments,
		arg.EnvVars,
		arg.Sha256Hash,
		arg.Transport,
		arg.TransportUrl,
		arg.TransportHeaders,
	)
	return err
}

const insertServerRemote = `-- name: InsertServerRemote :exec
INSERT INTO mcp_server_remote (
    server_id,
    transport,
    transport_url,
    transport_headers
) VALUES (
    $1,
    $2,
    $3,
    $4
)
`

type InsertServerRemoteParams struct {
	ServerID         uuid.UUID `json:"server_id"`
	Transport        string    `json:"transport"`
	TransportUrl     string    `json:"transport_url"`
	TransportHeaders []string  `json:"transport_headers"`
}

func (q *Queries) InsertServerRemote(ctx context.Context, arg InsertServerRemoteParams) error {
	_, err := q.db.Exec(ctx, insertServerRemote,
		arg.ServerID,
		arg.Transport,
		arg.TransportUrl,
		arg.TransportHeaders,
	)
	return err
}

const insertServerVersion = `-- name: InsertServerVersion :one
INSERT INTO mcp_server (
    name,
    version,
    reg_id,
    created_at,
    updated_at,
    description,
    title,
    website,
    upstream_meta,
    server_meta,
    repository_url,
    repository_id,
    repository_subfolder,
    repository_type
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10,
    $11,
    $12,
    $13,
    $14
)
RETURNING id
`

type InsertServerVersionParams struct {
	Name                string     `json:"name"`
	Version             string     `json:"version"`
	RegID               uuid.UUID  `json:"reg_id"`
	CreatedAt           *time.Time `json:"created_at"`
	UpdatedAt           *time.Time `json:"updated_at"`
	Description         *string    `json:"description"`
	Title               *string    `json:"title"`
	Website             *string    `json:"website"`
	UpstreamMeta        []byte     `json:"upstream_meta"`
	ServerMeta          []byte     `json:"server_meta"`
	RepositoryUrl       *string    `json:"repository_url"`
	RepositoryID        *string    `json:"repository_id"`
	RepositorySubfolder *string    `json:"repository_subfolder"`
	RepositoryType      *string    `json:"repository_type"`
}

func (q *Queries) InsertServerVersion(ctx context.Context, arg InsertServerVersionParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, insertServerVersion,
		arg.Name,
		arg.Version,
		arg.RegID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Description,
		arg.Title,
		arg.Website,
		arg.UpstreamMeta,
		arg.ServerMeta,
		arg.RepositoryUrl,
		arg.RepositoryID,
		arg.RepositorySubfolder,
		arg.RepositoryType,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const listServerPackages = `-- name: ListServerPackages :many
SELECT p.server_id,
       p.registry_type,
       p.pkg_registry_url,
       p.pkg_identifier,
       p.pkg_version,
       p.runtime_hint,
       p.runtime_arguments,
       p.package_arguments,
       p.env_vars,
       p.sha256_hash,
       p.transport,
       p.transport_url,
       p.transport_headers
  FROM mcp_server_package p
  JOIN mcp_server s ON p.server_id = s.id
 WHERE s.id = ANY($1::UUID[])
 ORDER BY p.pkg_version DESC
`

func (q *Queries) ListServerPackages(ctx context.Context, serverIds []uuid.UUID) ([]McpServerPackage, error) {
	rows, err := q.db.Query(ctx, listServerPackages, serverIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []McpServerPackage{}
	for rows.Next() {
		var i McpServerPackage
		if err := rows.Scan(
			&i.ServerID,
			&i.RegistryType,
			&i.PkgRegistryUrl,
			&i.PkgIdentifier,
			&i.PkgVersion,
			&i.RuntimeHint,
			&i.RuntimeArguments,
			&i.PackageArguments,
			&i.EnvVars,
			&i.Sha256Hash,
			&i.Transport,
			&i.TransportUrl,
			&i.TransportHeaders,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listServerRemotes = `-- name: ListServerRemotes :many
SELECT r.server_id,
       r.transport,
       r.transport_url,
       r.transport_headers
  FROM mcp_server_remote r
 WHERE r.server_id = ANY($1::UUID[])
 ORDER BY r.transport, r.transport_url
`

func (q *Queries) ListServerRemotes(ctx context.Context, serverIds []uuid.UUID) ([]McpServerRemote, error) {
	rows, err := q.db.Query(ctx, listServerRemotes, serverIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []McpServerRemote{}
	for rows.Next() {
		var i McpServerRemote
		if err := rows.Scan(
			&i.ServerID,
			&i.Transport,
			&i.TransportUrl,
			&i.TransportHeaders,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listServerVersions = `-- name: ListServerVersions :many
SELECT r.reg_type as registry_type,
       s.id,
       s.name,
       s.version,
       (l.latest_server_id IS NOT NULL)::boolean AS is_latest,
       s.created_at,
       s.updated_at,
       s.description,
       s.title,
       s.website,
       s.upstream_meta,
       s.server_meta,
       s.repository_url,
       s.repository_id,
       s.repository_subfolder,
       s.repository_type
  FROM mcp_server s
  JOIN registry r ON s.reg_id = r.id
  LEFT JOIN latest_server_version l ON s.id = l.latest_server_id
 WHERE s.name = $1
   AND ($2::text IS NULL OR r.name = $2::text)
   AND (($3::timestamp with time zone IS NULL OR s.created_at > $3)
    AND ($4::timestamp with time zone IS NULL OR s.created_at < $4))
 ORDER BY
 CASE WHEN $3::timestamp with time zone IS NULL THEN s.created_at END ASC,
 CASE WHEN $3::timestamp with time zone IS NULL THEN s.version END DESC -- acts as tie breaker
 LIMIT $5::bigint
`

type ListServerVersionsParams struct {
	Name         string     `json:"name"`
	RegistryName *string    `json:"registry_name"`
	Next         *time.Time `json:"next"`
	Prev         *time.Time `json:"prev"`
	Size         int64      `json:"size"`
}

type ListServerVersionsRow struct {
	RegistryType        RegistryType `json:"registry_type"`
	ID                  uuid.UUID    `json:"id"`
	Name                string       `json:"name"`
	Version             string       `json:"version"`
	IsLatest            bool         `json:"is_latest"`
	CreatedAt           *time.Time   `json:"created_at"`
	UpdatedAt           *time.Time   `json:"updated_at"`
	Description         *string      `json:"description"`
	Title               *string      `json:"title"`
	Website             *string      `json:"website"`
	UpstreamMeta        []byte       `json:"upstream_meta"`
	ServerMeta          []byte       `json:"server_meta"`
	RepositoryUrl       *string      `json:"repository_url"`
	RepositoryID        *string      `json:"repository_id"`
	RepositorySubfolder *string      `json:"repository_subfolder"`
	RepositoryType      *string      `json:"repository_type"`
}

func (q *Queries) ListServerVersions(ctx context.Context, arg ListServerVersionsParams) ([]ListServerVersionsRow, error) {
	rows, err := q.db.Query(ctx, listServerVersions,
		arg.Name,
		arg.RegistryName,
		arg.Next,
		arg.Prev,
		arg.Size,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListServerVersionsRow{}
	for rows.Next() {
		var i ListServerVersionsRow
		if err := rows.Scan(
			&i.RegistryType,
			&i.ID,
			&i.Name,
			&i.Version,
			&i.IsLatest,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Description,
			&i.Title,
			&i.Website,
			&i.UpstreamMeta,
			&i.ServerMeta,
			&i.RepositoryUrl,
			&i.RepositoryID,
			&i.RepositorySubfolder,
			&i.RepositoryType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listServers = `-- name: ListServers :many
SELECT r.reg_type as registry_type,
       s.id,
       s.name,
       s.version,
       (l.latest_server_id IS NOT NULL)::boolean AS is_latest,
       s.created_at,
       s.updated_at,
       s.description,
       s.title,
       s.website,
       s.upstream_meta,
       s.server_meta,
       s.repository_url,
       s.repository_id,
       s.repository_subfolder,
       s.repository_type
  FROM mcp_server s
  JOIN registry r ON s.reg_id = r.id
  LEFT JOIN latest_server_version l ON s.id = l.latest_server_id
 WHERE ($1::timestamp with time zone IS NULL OR s.created_at > $1::timestamp with time zone)
   AND ($2::timestamp with time zone IS NULL OR s.created_at < $2::timestamp with time zone)
   AND ($3::text IS NULL OR r.name = $3::text)
 ORDER BY
 -- next page sorting
 CASE WHEN $1::timestamp with time zone IS NULL THEN r.reg_type END ASC,
 CASE WHEN $1::timestamp with time zone IS NULL THEN s.name END ASC,
 CASE WHEN $1::timestamp with time zone IS NULL THEN s.created_at END ASC,
 CASE WHEN $1::timestamp with time zone IS NULL THEN s.version END ASC, -- acts as tie breaker
 -- previous page sorting
 CASE WHEN $2::timestamp with time zone IS NULL THEN r.reg_type END DESC,
 CASE WHEN $2::timestamp with time zone IS NULL THEN s.name END DESC,
 CASE WHEN $2::timestamp with time zone IS NULL THEN s.created_at END DESC,
 CASE WHEN $2::timestamp with time zone IS NULL THEN s.version END DESC -- acts as tie breaker
 LIMIT $4::bigint
`

type ListServersParams struct {
	Next         *time.Time `json:"next"`
	Prev         *time.Time `json:"prev"`
	RegistryName *string    `json:"registry_name"`
	Size         int64      `json:"size"`
}

type ListServersRow struct {
	RegistryType        RegistryType `json:"registry_type"`
	ID                  uuid.UUID    `json:"id"`
	Name                string       `json:"name"`
	Version             string       `json:"version"`
	IsLatest            bool         `json:"is_latest"`
	CreatedAt           *time.Time   `json:"created_at"`
	UpdatedAt           *time.Time   `json:"updated_at"`
	Description         *string      `json:"description"`
	Title               *string      `json:"title"`
	Website             *string      `json:"website"`
	UpstreamMeta        []byte       `json:"upstream_meta"`
	ServerMeta          []byte       `json:"server_meta"`
	RepositoryUrl       *string      `json:"repository_url"`
	RepositoryID        *string      `json:"repository_id"`
	RepositorySubfolder *string      `json:"repository_subfolder"`
	RepositoryType      *string      `json:"repository_type"`
}

func (q *Queries) ListServers(ctx context.Context, arg ListServersParams) ([]ListServersRow, error) {
	rows, err := q.db.Query(ctx, listServers,
		arg.Next,
		arg.Prev,
		arg.RegistryName,
		arg.Size,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListServersRow{}
	for rows.Next() {
		var i ListServersRow
		if err := rows.Scan(
			&i.RegistryType,
			&i.ID,
			&i.Name,
			&i.Version,
			&i.IsLatest,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Description,
			&i.Title,
			&i.Website,
			&i.UpstreamMeta,
			&i.ServerMeta,
			&i.RepositoryUrl,
			&i.RepositoryID,
			&i.RepositorySubfolder,
			&i.RepositoryType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertLatestServerVersion = `-- name: UpsertLatestServerVersion :one
INSERT INTO latest_server_version (
    reg_id,
    name,
    version,
    latest_server_id
) VALUES (
    $1,
    $2,
    $3,
    $4
) ON CONFLICT (reg_id, name)
  DO UPDATE SET
    version = $3,
    latest_server_id = $4
RETURNING latest_server_id
`

type UpsertLatestServerVersionParams struct {
	RegID    uuid.UUID `json:"reg_id"`
	Name     string    `json:"name"`
	Version  string    `json:"version"`
	ServerID uuid.UUID `json:"server_id"`
}

func (q *Queries) UpsertLatestServerVersion(ctx context.Context, arg UpsertLatestServerVersionParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, upsertLatestServerVersion,
		arg.RegID,
		arg.Name,
		arg.Version,
		arg.ServerID,
	)
	var latest_server_id uuid.UUID
	err := row.Scan(&latest_server_id)
	return latest_server_id, err
}
