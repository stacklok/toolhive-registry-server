// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: servers.sql

package sqlc

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const deleteOrphanedServers = `-- name: DeleteOrphanedServers :exec
WITH subset AS (
    SELECT e.id
      FROM registry_entry e
     WHERE reg_id = $1
       AND e.id != ALL($2::UUID[])
)
DELETE FROM mcp_server s
WHERE s.entry_id IN (SELECT id FROM subset)
`

type DeleteOrphanedServersParams struct {
	RegID   uuid.UUID   `json:"reg_id"`
	KeepIds []uuid.UUID `json:"keep_ids"`
}

func (q *Queries) DeleteOrphanedServers(ctx context.Context, arg DeleteOrphanedServersParams) error {
	_, err := q.db.Exec(ctx, deleteOrphanedServers, arg.RegID, arg.KeepIds)
	return err
}

const deleteServerIconsByServerId = `-- name: DeleteServerIconsByServerId :exec
DELETE FROM mcp_server_icon
WHERE entry_id = $1
`

func (q *Queries) DeleteServerIconsByServerId(ctx context.Context, entryID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteServerIconsByServerId, entryID)
	return err
}

const deleteServerPackagesByServerId = `-- name: DeleteServerPackagesByServerId :exec
DELETE FROM mcp_server_package
WHERE entry_id = $1
`

func (q *Queries) DeleteServerPackagesByServerId(ctx context.Context, entryID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteServerPackagesByServerId, entryID)
	return err
}

const deleteServerRemotesByServerId = `-- name: DeleteServerRemotesByServerId :exec
DELETE FROM mcp_server_remote
WHERE entry_id = $1
`

func (q *Queries) DeleteServerRemotesByServerId(ctx context.Context, entryID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteServerRemotesByServerId, entryID)
	return err
}

const deleteServersByRegistry = `-- name: DeleteServersByRegistry :exec
WITH registry_entries AS (
    SELECT e.id
      FROM registry_entry e
      JOIN mcp_server s ON e.id = s.entry_id
     WHERE e.reg_id = $1
)
DELETE FROM registry_entry
 WHERE id IN (SELECT id FROM registry_entries)
`

func (q *Queries) DeleteServersByRegistry(ctx context.Context, regID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteServersByRegistry, regID)
	return err
}

const getServerIDsByRegistryNameVersion = `-- name: GetServerIDsByRegistryNameVersion :many
SELECT entry_id, name, version
FROM registry_entry e
JOIN mcp_server s ON e.id = s.entry_id
WHERE e.reg_id = $1
`

type GetServerIDsByRegistryNameVersionRow struct {
	EntryID uuid.UUID `json:"entry_id"`
	Name    string    `json:"name"`
	Version string    `json:"version"`
}

func (q *Queries) GetServerIDsByRegistryNameVersion(ctx context.Context, regID uuid.UUID) ([]GetServerIDsByRegistryNameVersionRow, error) {
	rows, err := q.db.Query(ctx, getServerIDsByRegistryNameVersion, regID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetServerIDsByRegistryNameVersionRow{}
	for rows.Next() {
		var i GetServerIDsByRegistryNameVersionRow
		if err := rows.Scan(&i.EntryID, &i.Name, &i.Version); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getServerVersion = `-- name: GetServerVersion :one
SELECT r.reg_type as registry_type,
       e.id,
       e.name,
       e.version,
       (l.latest_entry_id IS NOT NULL)::boolean AS is_latest,
       e.created_at,
       e.updated_at,
       e.description,
       e.title,
       s.website,
       s.upstream_meta,
       s.server_meta,
       s.repository_url,
       s.repository_id,
       s.repository_subfolder,
       s.repository_type
  FROM mcp_server s
  JOIN registry_entry e ON s.entry_id = e.id
  JOIN registry r ON e.reg_id = r.id
  LEFT JOIN latest_entry_version l ON e.id = l.latest_entry_id
 WHERE e.name = $1
   AND e.version = $2
   AND ($3::text IS NULL OR r.name = $3::text)
`

type GetServerVersionParams struct {
	Name         string  `json:"name"`
	Version      string  `json:"version"`
	RegistryName *string `json:"registry_name"`
}

type GetServerVersionRow struct {
	RegistryType        RegistryType `json:"registry_type"`
	ID                  uuid.UUID    `json:"id"`
	Name                string       `json:"name"`
	Version             string       `json:"version"`
	IsLatest            bool         `json:"is_latest"`
	CreatedAt           *time.Time   `json:"created_at"`
	UpdatedAt           *time.Time   `json:"updated_at"`
	Description         *string      `json:"description"`
	Title               *string      `json:"title"`
	Website             *string      `json:"website"`
	UpstreamMeta        []byte       `json:"upstream_meta"`
	ServerMeta          []byte       `json:"server_meta"`
	RepositoryUrl       *string      `json:"repository_url"`
	RepositoryID        *string      `json:"repository_id"`
	RepositorySubfolder *string      `json:"repository_subfolder"`
	RepositoryType      *string      `json:"repository_type"`
}

func (q *Queries) GetServerVersion(ctx context.Context, arg GetServerVersionParams) (GetServerVersionRow, error) {
	row := q.db.QueryRow(ctx, getServerVersion, arg.Name, arg.Version, arg.RegistryName)
	var i GetServerVersionRow
	err := row.Scan(
		&i.RegistryType,
		&i.ID,
		&i.Name,
		&i.Version,
		&i.IsLatest,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Description,
		&i.Title,
		&i.Website,
		&i.UpstreamMeta,
		&i.ServerMeta,
		&i.RepositoryUrl,
		&i.RepositoryID,
		&i.RepositorySubfolder,
		&i.RepositoryType,
	)
	return i, err
}

const insertServerIcon = `-- name: InsertServerIcon :exec
INSERT INTO mcp_server_icon (
    entry_id,
    source_uri,
    mime_type,
    theme
) VALUES (
    $1,
    $2,
    $3,
    $4
)
`

type InsertServerIconParams struct {
	EntryID   uuid.UUID `json:"entry_id"`
	SourceUri string    `json:"source_uri"`
	MimeType  string    `json:"mime_type"`
	Theme     IconTheme `json:"theme"`
}

func (q *Queries) InsertServerIcon(ctx context.Context, arg InsertServerIconParams) error {
	_, err := q.db.Exec(ctx, insertServerIcon,
		arg.EntryID,
		arg.SourceUri,
		arg.MimeType,
		arg.Theme,
	)
	return err
}

const insertServerPackage = `-- name: InsertServerPackage :exec
INSERT INTO mcp_server_package (
    entry_id,
    registry_type,
    pkg_registry_url,
    pkg_identifier,
    pkg_version,
    runtime_hint,
    runtime_arguments,
    package_arguments,
    env_vars,
    sha256_hash,
    transport,
    transport_url,
    transport_headers
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10,
    $11,
    $12,
    $13
)
`

type InsertServerPackageParams struct {
	EntryID          uuid.UUID `json:"entry_id"`
	RegistryType     string    `json:"registry_type"`
	PkgRegistryUrl   string    `json:"pkg_registry_url"`
	PkgIdentifier    string    `json:"pkg_identifier"`
	PkgVersion       string    `json:"pkg_version"`
	RuntimeHint      *string   `json:"runtime_hint"`
	RuntimeArguments []string  `json:"runtime_arguments"`
	PackageArguments []string  `json:"package_arguments"`
	EnvVars          []byte    `json:"env_vars"`
	Sha256Hash       *string   `json:"sha256_hash"`
	Transport        string    `json:"transport"`
	TransportUrl     *string   `json:"transport_url"`
	TransportHeaders []byte    `json:"transport_headers"`
}

// TODO: this seems unused
func (q *Queries) InsertServerPackage(ctx context.Context, arg InsertServerPackageParams) error {
	_, err := q.db.Exec(ctx, insertServerPackage,
		arg.EntryID,
		arg.RegistryType,
		arg.PkgRegistryUrl,
		arg.PkgIdentifier,
		arg.PkgVersion,
		arg.RuntimeHint,
		arg.RuntimeArguments,
		arg.PackageArguments,
		arg.EnvVars,
		arg.Sha256Hash,
		arg.Transport,
		arg.TransportUrl,
		arg.TransportHeaders,
	)
	return err
}

const insertServerRemote = `-- name: InsertServerRemote :exec
INSERT INTO mcp_server_remote (
    entry_id,
    transport,
    transport_url,
    transport_headers
) VALUES (
    $1,
    $2,
    $3,
    $4
)
`

type InsertServerRemoteParams struct {
	EntryID          uuid.UUID `json:"entry_id"`
	Transport        string    `json:"transport"`
	TransportUrl     string    `json:"transport_url"`
	TransportHeaders []byte    `json:"transport_headers"`
}

func (q *Queries) InsertServerRemote(ctx context.Context, arg InsertServerRemoteParams) error {
	_, err := q.db.Exec(ctx, insertServerRemote,
		arg.EntryID,
		arg.Transport,
		arg.TransportUrl,
		arg.TransportHeaders,
	)
	return err
}

const insertServerVersion = `-- name: InsertServerVersion :one
INSERT INTO mcp_server (
    entry_id,
    website,
    upstream_meta,
    server_meta,
    repository_url,
    repository_id,
    repository_subfolder,
    repository_type
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8
)
RETURNING entry_id
`

type InsertServerVersionParams struct {
	EntryID             uuid.UUID `json:"entry_id"`
	Website             *string   `json:"website"`
	UpstreamMeta        []byte    `json:"upstream_meta"`
	ServerMeta          []byte    `json:"server_meta"`
	RepositoryUrl       *string   `json:"repository_url"`
	RepositoryID        *string   `json:"repository_id"`
	RepositorySubfolder *string   `json:"repository_subfolder"`
	RepositoryType      *string   `json:"repository_type"`
}

func (q *Queries) InsertServerVersion(ctx context.Context, arg InsertServerVersionParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, insertServerVersion,
		arg.EntryID,
		arg.Website,
		arg.UpstreamMeta,
		arg.ServerMeta,
		arg.RepositoryUrl,
		arg.RepositoryID,
		arg.RepositorySubfolder,
		arg.RepositoryType,
	)
	var entry_id uuid.UUID
	err := row.Scan(&entry_id)
	return entry_id, err
}

const insertServerVersionForSync = `-- name: InsertServerVersionForSync :one
INSERT INTO mcp_server (
    entry_id,
    website,
    upstream_meta,
    server_meta,
    repository_url,
    repository_id,
    repository_subfolder,
    repository_type
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8
)
RETURNING entry_id
`

type InsertServerVersionForSyncParams struct {
	EntryID             uuid.UUID `json:"entry_id"`
	Website             *string   `json:"website"`
	UpstreamMeta        []byte    `json:"upstream_meta"`
	ServerMeta          []byte    `json:"server_meta"`
	RepositoryUrl       *string   `json:"repository_url"`
	RepositoryID        *string   `json:"repository_id"`
	RepositorySubfolder *string   `json:"repository_subfolder"`
	RepositoryType      *string   `json:"repository_type"`
}

func (q *Queries) InsertServerVersionForSync(ctx context.Context, arg InsertServerVersionForSyncParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, insertServerVersionForSync,
		arg.EntryID,
		arg.Website,
		arg.UpstreamMeta,
		arg.ServerMeta,
		arg.RepositoryUrl,
		arg.RepositoryID,
		arg.RepositorySubfolder,
		arg.RepositoryType,
	)
	var entry_id uuid.UUID
	err := row.Scan(&entry_id)
	return entry_id, err
}

const listServerPackages = `-- name: ListServerPackages :many
SELECT p.entry_id,
       p.registry_type,
       p.pkg_registry_url,
       p.pkg_identifier,
       p.pkg_version,
       p.runtime_hint,
       p.runtime_arguments,
       p.package_arguments,
       p.env_vars,
       p.sha256_hash,
       p.transport,
       p.transport_url,
       p.transport_headers
  FROM mcp_server_package p
  JOIN mcp_server s ON p.entry_id = s.entry_id
 WHERE s.entry_id = ANY($1::UUID[])
 ORDER BY p.pkg_version DESC
`

type ListServerPackagesRow struct {
	EntryID          uuid.UUID `json:"entry_id"`
	RegistryType     string    `json:"registry_type"`
	PkgRegistryUrl   string    `json:"pkg_registry_url"`
	PkgIdentifier    string    `json:"pkg_identifier"`
	PkgVersion       string    `json:"pkg_version"`
	RuntimeHint      *string   `json:"runtime_hint"`
	RuntimeArguments []string  `json:"runtime_arguments"`
	PackageArguments []string  `json:"package_arguments"`
	EnvVars          []byte    `json:"env_vars"`
	Sha256Hash       *string   `json:"sha256_hash"`
	Transport        string    `json:"transport"`
	TransportUrl     *string   `json:"transport_url"`
	TransportHeaders []byte    `json:"transport_headers"`
}

func (q *Queries) ListServerPackages(ctx context.Context, entryIds []uuid.UUID) ([]ListServerPackagesRow, error) {
	rows, err := q.db.Query(ctx, listServerPackages, entryIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListServerPackagesRow{}
	for rows.Next() {
		var i ListServerPackagesRow
		if err := rows.Scan(
			&i.EntryID,
			&i.RegistryType,
			&i.PkgRegistryUrl,
			&i.PkgIdentifier,
			&i.PkgVersion,
			&i.RuntimeHint,
			&i.RuntimeArguments,
			&i.PackageArguments,
			&i.EnvVars,
			&i.Sha256Hash,
			&i.Transport,
			&i.TransportUrl,
			&i.TransportHeaders,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listServerRemotes = `-- name: ListServerRemotes :many
SELECT r.entry_id,
       r.transport,
       r.transport_url,
       r.transport_headers
  FROM mcp_server_remote r
  JOIN mcp_server s ON r.entry_id = s.entry_id
 WHERE s.entry_id = ANY($1::UUID[])
 ORDER BY r.transport, r.transport_url
`

func (q *Queries) ListServerRemotes(ctx context.Context, entryIds []uuid.UUID) ([]McpServerRemote, error) {
	rows, err := q.db.Query(ctx, listServerRemotes, entryIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []McpServerRemote{}
	for rows.Next() {
		var i McpServerRemote
		if err := rows.Scan(
			&i.EntryID,
			&i.Transport,
			&i.TransportUrl,
			&i.TransportHeaders,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listServerVersions = `-- name: ListServerVersions :many
SELECT r.reg_type as registry_type,
       e.id,
       e.name,
       e.version,
       (l.latest_entry_id IS NOT NULL)::boolean AS is_latest,
       e.created_at,
       e.updated_at,
       e.description,
       e.title,
       s.website,
       s.upstream_meta,
       s.server_meta,
       s.repository_url,
       s.repository_id,
       s.repository_subfolder,
       s.repository_type
  FROM mcp_server s
  JOIN registry_entry e ON s.entry_id = e.id
  JOIN registry r ON e.reg_id = r.id
  LEFT JOIN latest_entry_version l ON e.id = l.latest_entry_id
 WHERE e.name = $1
   AND ($2::text IS NULL OR r.name = $2::text)
   AND (($3::timestamp with time zone IS NULL OR e.created_at > $3)
    AND ($4::timestamp with time zone IS NULL OR e.created_at < $4))
 ORDER BY
 CASE WHEN $3::timestamp with time zone IS NULL THEN e.created_at END ASC,
 CASE WHEN $3::timestamp with time zone IS NULL THEN e.version END DESC -- acts as tie breaker
 LIMIT $5::bigint
`

type ListServerVersionsParams struct {
	Name         string     `json:"name"`
	RegistryName *string    `json:"registry_name"`
	Next         *time.Time `json:"next"`
	Prev         *time.Time `json:"prev"`
	Size         int64      `json:"size"`
}

type ListServerVersionsRow struct {
	RegistryType        RegistryType `json:"registry_type"`
	ID                  uuid.UUID    `json:"id"`
	Name                string       `json:"name"`
	Version             string       `json:"version"`
	IsLatest            bool         `json:"is_latest"`
	CreatedAt           *time.Time   `json:"created_at"`
	UpdatedAt           *time.Time   `json:"updated_at"`
	Description         *string      `json:"description"`
	Title               *string      `json:"title"`
	Website             *string      `json:"website"`
	UpstreamMeta        []byte       `json:"upstream_meta"`
	ServerMeta          []byte       `json:"server_meta"`
	RepositoryUrl       *string      `json:"repository_url"`
	RepositoryID        *string      `json:"repository_id"`
	RepositorySubfolder *string      `json:"repository_subfolder"`
	RepositoryType      *string      `json:"repository_type"`
}

func (q *Queries) ListServerVersions(ctx context.Context, arg ListServerVersionsParams) ([]ListServerVersionsRow, error) {
	rows, err := q.db.Query(ctx, listServerVersions,
		arg.Name,
		arg.RegistryName,
		arg.Next,
		arg.Prev,
		arg.Size,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListServerVersionsRow{}
	for rows.Next() {
		var i ListServerVersionsRow
		if err := rows.Scan(
			&i.RegistryType,
			&i.ID,
			&i.Name,
			&i.Version,
			&i.IsLatest,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Description,
			&i.Title,
			&i.Website,
			&i.UpstreamMeta,
			&i.ServerMeta,
			&i.RepositoryUrl,
			&i.RepositoryID,
			&i.RepositorySubfolder,
			&i.RepositoryType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listServers = `-- name: ListServers :many
SELECT r.reg_type as registry_type,
       e.id,
       e.name,
       e.version,
       (l.latest_entry_id IS NOT NULL)::boolean AS is_latest,
       e.created_at,
       e.updated_at,
       e.description,
       e.title,
       s.website,
       s.upstream_meta,
       s.server_meta,
       s.repository_url,
       s.repository_id,
       s.repository_subfolder,
       s.repository_type
  FROM mcp_server s
  JOIN registry_entry e ON s.entry_id = e.id
  JOIN registry r ON e.reg_id = r.id
  LEFT JOIN latest_entry_version l ON e.id = l.latest_entry_id
 WHERE ($1::text IS NULL OR r.name = $1::text)
   AND ($2::text IS NULL OR (
       LOWER(e.name) LIKE LOWER('%' || $2::text || '%')
       OR LOWER(e.title) LIKE LOWER('%' || $2::text || '%')
       OR LOWER(e.description) LIKE LOWER('%' || $2::text || '%')
   ))
   -- Filter by updated_since if provided
   AND ($3::timestamp with time zone IS NULL OR e.updated_at > $3::timestamp with time zone)
   -- Compound cursor comparison: (name, version) > (cursor_name, cursor_version)
   -- This ensures deterministic pagination even when timestamps are identical
   AND (
       $4::text IS NULL
       OR (e.name, e.version) > ($4::text, $5::text)
   )
   AND (
       $6::text IS NULL OR
       e.version = $6::text OR
       ($6::text = 'latest' AND l.latest_entry_id = e.id)
   )
 ORDER BY e.name ASC, e.version ASC
 LIMIT $7::bigint
`

type ListServersParams struct {
	RegistryName  *string    `json:"registry_name"`
	Search        *string    `json:"search"`
	UpdatedSince  *time.Time `json:"updated_since"`
	CursorName    *string    `json:"cursor_name"`
	CursorVersion *string    `json:"cursor_version"`
	Version       *string    `json:"version"`
	Size          int64      `json:"size"`
}

type ListServersRow struct {
	RegistryType        RegistryType `json:"registry_type"`
	ID                  uuid.UUID    `json:"id"`
	Name                string       `json:"name"`
	Version             string       `json:"version"`
	IsLatest            bool         `json:"is_latest"`
	CreatedAt           *time.Time   `json:"created_at"`
	UpdatedAt           *time.Time   `json:"updated_at"`
	Description         *string      `json:"description"`
	Title               *string      `json:"title"`
	Website             *string      `json:"website"`
	UpstreamMeta        []byte       `json:"upstream_meta"`
	ServerMeta          []byte       `json:"server_meta"`
	RepositoryUrl       *string      `json:"repository_url"`
	RepositoryID        *string      `json:"repository_id"`
	RepositorySubfolder *string      `json:"repository_subfolder"`
	RepositoryType      *string      `json:"repository_type"`
}

// Cursor-based pagination using (name, version) compound cursor.
// The cursor_name and cursor_version parameters define the starting point.
// When cursor is provided, results start AFTER the specified (name, version) tuple.
func (q *Queries) ListServers(ctx context.Context, arg ListServersParams) ([]ListServersRow, error) {
	rows, err := q.db.Query(ctx, listServers,
		arg.RegistryName,
		arg.Search,
		arg.UpdatedSince,
		arg.CursorName,
		arg.CursorVersion,
		arg.Version,
		arg.Size,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListServersRow{}
	for rows.Next() {
		var i ListServersRow
		if err := rows.Scan(
			&i.RegistryType,
			&i.ID,
			&i.Name,
			&i.Version,
			&i.IsLatest,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Description,
			&i.Title,
			&i.Website,
			&i.UpstreamMeta,
			&i.ServerMeta,
			&i.RepositoryUrl,
			&i.RepositoryID,
			&i.RepositorySubfolder,
			&i.RepositoryType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertLatestServerVersion = `-- name: UpsertLatestServerVersion :one
INSERT INTO latest_entry_version (
    reg_id,
    name,
    version,
    latest_entry_id
) VALUES (
    $1,
    $2,
    $3,
    $4
) ON CONFLICT (reg_id, name)
  DO UPDATE SET
    version = $3,
    latest_entry_id = $4
RETURNING latest_entry_id
`

type UpsertLatestServerVersionParams struct {
	RegID   uuid.UUID `json:"reg_id"`
	Name    string    `json:"name"`
	Version string    `json:"version"`
	EntryID uuid.UUID `json:"entry_id"`
}

func (q *Queries) UpsertLatestServerVersion(ctx context.Context, arg UpsertLatestServerVersionParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, upsertLatestServerVersion,
		arg.RegID,
		arg.Name,
		arg.Version,
		arg.EntryID,
	)
	var latest_entry_id uuid.UUID
	err := row.Scan(&latest_entry_id)
	return latest_entry_id, err
}

const upsertServerVersionForSync = `-- name: UpsertServerVersionForSync :one
INSERT INTO mcp_server (
    entry_id,
    website,
    upstream_meta,
    server_meta,
    repository_url,
    repository_id,
    repository_subfolder,
    repository_type
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8
)
ON CONFLICT (entry_id)
DO UPDATE SET
    website = $2,
    upstream_meta = $3,
    server_meta = $4,
    repository_url = $5,
    repository_id = $6,
    repository_subfolder = $7,
    repository_type = $8
RETURNING entry_id
`

type UpsertServerVersionForSyncParams struct {
	EntryID             uuid.UUID `json:"entry_id"`
	Website             *string   `json:"website"`
	UpstreamMeta        []byte    `json:"upstream_meta"`
	ServerMeta          []byte    `json:"server_meta"`
	RepositoryUrl       *string   `json:"repository_url"`
	RepositoryID        *string   `json:"repository_id"`
	RepositorySubfolder *string   `json:"repository_subfolder"`
	RepositoryType      *string   `json:"repository_type"`
}

func (q *Queries) UpsertServerVersionForSync(ctx context.Context, arg UpsertServerVersionForSyncParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, upsertServerVersionForSync,
		arg.EntryID,
		arg.Website,
		arg.UpstreamMeta,
		arg.ServerMeta,
		arg.RepositoryUrl,
		arg.RepositoryID,
		arg.RepositorySubfolder,
		arg.RepositoryType,
	)
	var entry_id uuid.UUID
	err := row.Scan(&entry_id)
	return entry_id, err
}
