// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: servers.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const listServerPackages = `-- name: ListServerPackages :many
SELECT p.server_id,
       p.registry_type,
       p.pkg_registry_url,
       p.pkg_identifier,
       p.pkg_version,
       p.runtime_hint,
       p.runtime_arguments,
       p.package_arguments,
       p.env_vars,
       p.sha256_hash,
       p.transport,
       p.transport_url,
       p.transport_headers
  FROM mcp_server_package p
  JOIN mcp_server s ON p.server_id = s.id
 WHERE s.id = ANY($1::UUID[])
 ORDER BY p.pkg_version DESC
`

func (q *Queries) ListServerPackages(ctx context.Context, serverIds []pgtype.UUID) ([]McpServerPackage, error) {
	rows, err := q.db.Query(ctx, listServerPackages, serverIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []McpServerPackage{}
	for rows.Next() {
		var i McpServerPackage
		if err := rows.Scan(
			&i.ServerID,
			&i.RegistryType,
			&i.PkgRegistryUrl,
			&i.PkgIdentifier,
			&i.PkgVersion,
			&i.RuntimeHint,
			&i.RuntimeArguments,
			&i.PackageArguments,
			&i.EnvVars,
			&i.Sha256Hash,
			&i.Transport,
			&i.TransportUrl,
			&i.TransportHeaders,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listServerRemotes = `-- name: ListServerRemotes :many
SELECT r.server_id,
       r.transport,
       r.transport_url,
       r.transport_headers
  FROM mcp_server_remote r
 WHERE r.server_id = ANY($1::UUID[])
 ORDER BY r.transport, r.transport_url
`

func (q *Queries) ListServerRemotes(ctx context.Context, serverIds []pgtype.UUID) ([]McpServerRemote, error) {
	rows, err := q.db.Query(ctx, listServerRemotes, serverIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []McpServerRemote{}
	for rows.Next() {
		var i McpServerRemote
		if err := rows.Scan(
			&i.ServerID,
			&i.Transport,
			&i.TransportUrl,
			&i.TransportHeaders,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listServerVersions = `-- name: ListServerVersions :many
SELECT s.id,
       s.name,
       s.version,
       s.created_at,
       s.updated_at,
       s.description,
       s.title,
       s.website,
       s.upstream_meta,
       s.server_meta,
       s.repository_url,
       s.repository_id,
       s.repository_subfolder,
       s.repository_type
  FROM mcp_server s
 WHERE s.name = $1
   AND (($2::timestamp with time zone IS NULL OR s.created_at > $2)
       OR ($3::timestamp with time zone IS NULL AND s.created_at < $3))
 ORDER BY
 CASE WHEN $2::timestamp with time zone IS NULL THEN s.created_at END ASC,
 CASE WHEN $2::timestamp with time zone IS NULL THEN s.version END DESC -- acts as tie breaker
 LIMIT $4::bigint
`

type ListServerVersionsParams struct {
	Name string             `json:"name"`
	Next pgtype.Timestamptz `json:"next"`
	Prev pgtype.Timestamptz `json:"prev"`
	Size int64              `json:"size"`
}

type ListServerVersionsRow struct {
	ID                  pgtype.UUID        `json:"id"`
	Name                string             `json:"name"`
	Version             string             `json:"version"`
	CreatedAt           pgtype.Timestamptz `json:"created_at"`
	UpdatedAt           pgtype.Timestamptz `json:"updated_at"`
	Description         pgtype.Text        `json:"description"`
	Title               pgtype.Text        `json:"title"`
	Website             pgtype.Text        `json:"website"`
	UpstreamMeta        []byte             `json:"upstream_meta"`
	ServerMeta          []byte             `json:"server_meta"`
	RepositoryUrl       pgtype.Text        `json:"repository_url"`
	RepositoryID        pgtype.Text        `json:"repository_id"`
	RepositorySubfolder pgtype.Text        `json:"repository_subfolder"`
	RepositoryType      pgtype.Text        `json:"repository_type"`
}

func (q *Queries) ListServerVersions(ctx context.Context, arg ListServerVersionsParams) ([]ListServerVersionsRow, error) {
	rows, err := q.db.Query(ctx, listServerVersions,
		arg.Name,
		arg.Next,
		arg.Prev,
		arg.Size,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListServerVersionsRow{}
	for rows.Next() {
		var i ListServerVersionsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Version,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Description,
			&i.Title,
			&i.Website,
			&i.UpstreamMeta,
			&i.ServerMeta,
			&i.RepositoryUrl,
			&i.RepositoryID,
			&i.RepositorySubfolder,
			&i.RepositoryType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listServers = `-- name: ListServers :many
SELECT r.reg_type as registry_type,
       s.id,
       s.name,
       s.version,
       (l.latest_server_id IS NOT NULL)::boolean AS is_latest,
       s.created_at,
       s.updated_at,
       s.description,
       s.title,
       s.website,
       s.upstream_meta,
       s.server_meta,
       s.repository_url,
       s.repository_id,
       s.repository_subfolder,
       s.repository_type
  FROM mcp_server s
  JOIN registry r ON s.reg_id = r.id
  LEFT JOIN latest_server_version l ON s.id = l.latest_server_id
 WHERE ($1::timestamp with time zone IS NULL OR s.created_at > $1)
    OR ($2::timestamp with time zone IS NULL AND s.created_at < $2)
 ORDER BY
 -- next page sorting
 CASE WHEN $1::timestamp with time zone IS NULL THEN r.reg_type END ASC,
 CASE WHEN $1::timestamp with time zone IS NULL THEN s.name END ASC,
 CASE WHEN $1::timestamp with time zone IS NULL THEN s.created_at END ASC,
 CASE WHEN $1::timestamp with time zone IS NULL THEN s.version END ASC, -- acts as tie breaker
 -- previous page sorting
 CASE WHEN $2::timestamp with time zone IS NULL THEN r.reg_type END DESC,
 CASE WHEN $2::timestamp with time zone IS NULL THEN s.name END DESC,
 CASE WHEN $2::timestamp with time zone IS NULL THEN s.created_at END DESC,
 CASE WHEN $2::timestamp with time zone IS NULL THEN s.version END DESC -- acts as tie breaker
 LIMIT $3::bigint
`

type ListServersParams struct {
	Next pgtype.Timestamptz `json:"next"`
	Prev pgtype.Timestamptz `json:"prev"`
	Size int64              `json:"size"`
}

type ListServersRow struct {
	RegistryType        RegistryType       `json:"registry_type"`
	ID                  pgtype.UUID        `json:"id"`
	Name                string             `json:"name"`
	Version             string             `json:"version"`
	IsLatest            bool               `json:"is_latest"`
	CreatedAt           pgtype.Timestamptz `json:"created_at"`
	UpdatedAt           pgtype.Timestamptz `json:"updated_at"`
	Description         pgtype.Text        `json:"description"`
	Title               pgtype.Text        `json:"title"`
	Website             pgtype.Text        `json:"website"`
	UpstreamMeta        []byte             `json:"upstream_meta"`
	ServerMeta          []byte             `json:"server_meta"`
	RepositoryUrl       pgtype.Text        `json:"repository_url"`
	RepositoryID        pgtype.Text        `json:"repository_id"`
	RepositorySubfolder pgtype.Text        `json:"repository_subfolder"`
	RepositoryType      pgtype.Text        `json:"repository_type"`
}

func (q *Queries) ListServers(ctx context.Context, arg ListServersParams) ([]ListServersRow, error) {
	rows, err := q.db.Query(ctx, listServers, arg.Next, arg.Prev, arg.Size)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListServersRow{}
	for rows.Next() {
		var i ListServersRow
		if err := rows.Scan(
			&i.RegistryType,
			&i.ID,
			&i.Name,
			&i.Version,
			&i.IsLatest,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Description,
			&i.Title,
			&i.Website,
			&i.UpstreamMeta,
			&i.ServerMeta,
			&i.RepositoryUrl,
			&i.RepositoryID,
			&i.RepositorySubfolder,
			&i.RepositoryType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertLatestServerVersion = `-- name: UpsertLatestServerVersion :one
INSERT INTO latest_server_version (
    reg_id,
    name,
    version,
    latest_server_id
) VALUES (
    $1,
    $2,
    $3,
    $4
) ON CONFLICT (reg_id, name)
  DO UPDATE SET
    version = $3,
    latest_server_id = $4
RETURNING latest_server_id
`

type UpsertLatestServerVersionParams struct {
	RegID    pgtype.UUID `json:"reg_id"`
	Name     string      `json:"name"`
	Version  string      `json:"version"`
	ServerID pgtype.UUID `json:"server_id"`
}

func (q *Queries) UpsertLatestServerVersion(ctx context.Context, arg UpsertLatestServerVersionParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, upsertLatestServerVersion,
		arg.RegID,
		arg.Name,
		arg.Version,
		arg.ServerID,
	)
	var latest_server_id pgtype.UUID
	err := row.Scan(&latest_server_id)
	return latest_server_id, err
}

const upsertServerIcon = `-- name: UpsertServerIcon :exec
INSERT INTO mcp_server_icon (
    server_id,
    source_uri,
    mime_type,
    theme
) VALUES (
    $1,
    $2,
    $3,
    $4
) ON CONFLICT (server_id, source_uri, mime_type, theme)
  DO UPDATE SET
    theme = $4
`

type UpsertServerIconParams struct {
	ServerID  pgtype.UUID `json:"server_id"`
	SourceUri string      `json:"source_uri"`
	MimeType  string      `json:"mime_type"`
	Theme     IconTheme   `json:"theme"`
}

func (q *Queries) UpsertServerIcon(ctx context.Context, arg UpsertServerIconParams) error {
	_, err := q.db.Exec(ctx, upsertServerIcon,
		arg.ServerID,
		arg.SourceUri,
		arg.MimeType,
		arg.Theme,
	)
	return err
}

const upsertServerPackage = `-- name: UpsertServerPackage :exec
INSERT INTO mcp_server_package (
    server_id,
    registry_type,
    pkg_registry_url,
    pkg_identifier,
    pkg_version,
    runtime_hint,
    runtime_arguments,
    package_arguments,
    env_vars,
    sha256_hash,
    transport,
    transport_url,
    transport_headers
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10,
    $11,
    $12,
    $13
)
`

type UpsertServerPackageParams struct {
	ServerID         pgtype.UUID `json:"server_id"`
	RegistryType     string      `json:"registry_type"`
	PkgRegistryUrl   string      `json:"pkg_registry_url"`
	PkgIdentifier    string      `json:"pkg_identifier"`
	PkgVersion       string      `json:"pkg_version"`
	RuntimeHint      pgtype.Text `json:"runtime_hint"`
	RuntimeArguments []string    `json:"runtime_arguments"`
	PackageArguments []string    `json:"package_arguments"`
	EnvVars          []string    `json:"env_vars"`
	Sha256Hash       pgtype.Text `json:"sha256_hash"`
	Transport        string      `json:"transport"`
	TransportUrl     pgtype.Text `json:"transport_url"`
	TransportHeaders []string    `json:"transport_headers"`
}

func (q *Queries) UpsertServerPackage(ctx context.Context, arg UpsertServerPackageParams) error {
	_, err := q.db.Exec(ctx, upsertServerPackage,
		arg.ServerID,
		arg.RegistryType,
		arg.PkgRegistryUrl,
		arg.PkgIdentifier,
		arg.PkgVersion,
		arg.RuntimeHint,
		arg.RuntimeArguments,
		arg.PackageArguments,
		arg.EnvVars,
		arg.Sha256Hash,
		arg.Transport,
		arg.TransportUrl,
		arg.TransportHeaders,
	)
	return err
}

const upsertServerRemote = `-- name: UpsertServerRemote :exec
INSERT INTO mcp_server_remote (
    server_id,
    transport,
    transport_url,
    transport_headers
) VALUES (
    $1,
    $2,
    $3,
    $4
) ON CONFLICT (server_id, transport, transport_url)
  DO UPDATE SET
    transport_headers = $4
`

type UpsertServerRemoteParams struct {
	ServerID         pgtype.UUID `json:"server_id"`
	Transport        string      `json:"transport"`
	TransportUrl     pgtype.Text `json:"transport_url"`
	TransportHeaders []string    `json:"transport_headers"`
}

func (q *Queries) UpsertServerRemote(ctx context.Context, arg UpsertServerRemoteParams) error {
	_, err := q.db.Exec(ctx, upsertServerRemote,
		arg.ServerID,
		arg.Transport,
		arg.TransportUrl,
		arg.TransportHeaders,
	)
	return err
}

const upsertServerVersion = `-- name: UpsertServerVersion :one
INSERT INTO mcp_server (
    name,
    version,
    reg_id,
    created_at,
    updated_at,
    description,
    title,
    website,
    upstream_meta,
    server_meta,
    repository_url,
    repository_id,
    repository_subfolder,
    repository_type
) VALUES (
    $1,
    $2,
    $3,
    CURRENT_TIMESTAMP,
    CURRENT_TIMESTAMP,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10,
    $11,
    $12
) ON CONFLICT (reg_id, name, version)
  DO UPDATE SET
    updated_at = CURRENT_TIMESTAMP,
    description = $4,
    title = $5,
    website = $6,
    upstream_meta = $7,
    server_meta = $8,
    repository_url = $9,
    repository_id = $10,
    repository_subfolder = $11,
    repository_type = $12
RETURNING id
`

type UpsertServerVersionParams struct {
	Name                string      `json:"name"`
	Version             string      `json:"version"`
	RegID               pgtype.UUID `json:"reg_id"`
	Description         pgtype.Text `json:"description"`
	Title               pgtype.Text `json:"title"`
	Website             pgtype.Text `json:"website"`
	UpstreamMeta        []byte      `json:"upstream_meta"`
	ServerMeta          []byte      `json:"server_meta"`
	RepositoryUrl       pgtype.Text `json:"repository_url"`
	RepositoryID        pgtype.Text `json:"repository_id"`
	RepositorySubfolder pgtype.Text `json:"repository_subfolder"`
	RepositoryType      pgtype.Text `json:"repository_type"`
}

func (q *Queries) UpsertServerVersion(ctx context.Context, arg UpsertServerVersionParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, upsertServerVersion,
		arg.Name,
		arg.Version,
		arg.RegID,
		arg.Description,
		arg.Title,
		arg.Website,
		arg.UpstreamMeta,
		arg.ServerMeta,
		arg.RepositoryUrl,
		arg.RepositoryID,
		arg.RepositorySubfolder,
		arg.RepositoryType,
	)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}
