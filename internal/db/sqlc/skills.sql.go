// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: skills.sql

package sqlc

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const deleteOrphanedSkills = `-- name: DeleteOrphanedSkills :exec
WITH subset AS (
    SELECT e.id
      FROM registry_entry e
     WHERE reg_id = $1
       AND e.id != ALL($2::UUID[])
)
DELETE FROM skill s
 WHERE s.entry_id IN (SELECT id FROM subset)
`

type DeleteOrphanedSkillsParams struct {
	RegID   uuid.UUID   `json:"reg_id"`
	KeepIds []uuid.UUID `json:"keep_ids"`
}

func (q *Queries) DeleteOrphanedSkills(ctx context.Context, arg DeleteOrphanedSkillsParams) error {
	_, err := q.db.Exec(ctx, deleteOrphanedSkills, arg.RegID, arg.KeepIds)
	return err
}

const deleteSkillsByRegistry = `-- name: DeleteSkillsByRegistry :exec
WITH registry_entries AS (
    SELECT e.id
      FROM registry_entry e
      JOIN skill s ON e.id = s.entry_id
     WHERE e.reg_id = $1
)
DELETE FROM registry_entry
 WHERE id IN (SELECT id FROM registry_entries)
`

func (q *Queries) DeleteSkillsByRegistry(ctx context.Context, regID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteSkillsByRegistry, regID)
	return err
}

const getSkillVersion = `-- name: GetSkillVersion :one
SELECT r.reg_type AS registry_type,
       e.id,
       e.name,
       e.version,
       (l.latest_entry_id IS NOT NULL)::boolean AS is_latest,
       e.created_at,
       e.updated_at,
       e.description,
       e.title,
       s.entry_id AS skill_entry_id,
       s.namespace,
       s.status,
       s.license,
       s.compatibility,
       s.allowed_tools,
       s.repository,
       s.icons,
       s.metadata,
       s.extension_meta
  FROM skill s
  JOIN registry_entry e ON s.entry_id = e.id
  JOIN registry r ON e.reg_id = r.id
  LEFT JOIN latest_entry_version l ON e.id = l.latest_entry_id
 WHERE e.name = $1
   AND (e.version = $2::text
       OR ($2::text = 'latest' AND l.latest_entry_id = e.id)
   )
   AND ($3::text IS NULL OR r.name = $3::text)
`

type GetSkillVersionParams struct {
	Name         string  `json:"name"`
	Version      string  `json:"version"`
	RegistryName *string `json:"registry_name"`
}

type GetSkillVersionRow struct {
	RegistryType  RegistryType `json:"registry_type"`
	ID            uuid.UUID    `json:"id"`
	Name          string       `json:"name"`
	Version       string       `json:"version"`
	IsLatest      bool         `json:"is_latest"`
	CreatedAt     *time.Time   `json:"created_at"`
	UpdatedAt     *time.Time   `json:"updated_at"`
	Description   *string      `json:"description"`
	Title         *string      `json:"title"`
	SkillEntryID  uuid.UUID    `json:"skill_entry_id"`
	Namespace     string       `json:"namespace"`
	Status        SkillStatus  `json:"status"`
	License       *string      `json:"license"`
	Compatibility *string      `json:"compatibility"`
	AllowedTools  []string     `json:"allowed_tools"`
	Repository    []byte       `json:"repository"`
	Icons         []byte       `json:"icons"`
	Metadata      []byte       `json:"metadata"`
	ExtensionMeta []byte       `json:"extension_meta"`
}

func (q *Queries) GetSkillVersion(ctx context.Context, arg GetSkillVersionParams) (GetSkillVersionRow, error) {
	row := q.db.QueryRow(ctx, getSkillVersion, arg.Name, arg.Version, arg.RegistryName)
	var i GetSkillVersionRow
	err := row.Scan(
		&i.RegistryType,
		&i.ID,
		&i.Name,
		&i.Version,
		&i.IsLatest,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Description,
		&i.Title,
		&i.SkillEntryID,
		&i.Namespace,
		&i.Status,
		&i.License,
		&i.Compatibility,
		&i.AllowedTools,
		&i.Repository,
		&i.Icons,
		&i.Metadata,
		&i.ExtensionMeta,
	)
	return i, err
}

const insertSkillGitPackage = `-- name: InsertSkillGitPackage :exec
INSERT INTO skill_git_package (
    skill_entry_id,
    url,
    ref,
    commit_sha,
    subfolder
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5
)
`

type InsertSkillGitPackageParams struct {
	SkillEntryID uuid.UUID `json:"skill_entry_id"`
	Url          string    `json:"url"`
	Ref          *string   `json:"ref"`
	CommitSha    *string   `json:"commit_sha"`
	Subfolder    *string   `json:"subfolder"`
}

func (q *Queries) InsertSkillGitPackage(ctx context.Context, arg InsertSkillGitPackageParams) error {
	_, err := q.db.Exec(ctx, insertSkillGitPackage,
		arg.SkillEntryID,
		arg.Url,
		arg.Ref,
		arg.CommitSha,
		arg.Subfolder,
	)
	return err
}

const insertSkillOciPackage = `-- name: InsertSkillOciPackage :exec
INSERT INTO skill_oci_package (
    skill_entry_id,
    identifier,
    digest,
    media_type
) VALUES (
    $1,
    $2,
    $3,
    $4
)
`

type InsertSkillOciPackageParams struct {
	SkillEntryID uuid.UUID `json:"skill_entry_id"`
	Identifier   string    `json:"identifier"`
	Digest       *string   `json:"digest"`
	MediaType    *string   `json:"media_type"`
}

func (q *Queries) InsertSkillOciPackage(ctx context.Context, arg InsertSkillOciPackageParams) error {
	_, err := q.db.Exec(ctx, insertSkillOciPackage,
		arg.SkillEntryID,
		arg.Identifier,
		arg.Digest,
		arg.MediaType,
	)
	return err
}

const insertSkillVersion = `-- name: InsertSkillVersion :one
INSERT INTO skill (
    entry_id,
    namespace,
    status,
    license,
    compatibility,
    allowed_tools,
    repository,
    icons,
    metadata,
    extension_meta
) VALUES (
    $1,
    $2,
    COALESCE($3::skill_status, 'ACTIVE'),
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10
)
RETURNING entry_id
`

type InsertSkillVersionParams struct {
	EntryID       uuid.UUID       `json:"entry_id"`
	Namespace     string          `json:"namespace"`
	Status        NullSkillStatus `json:"status"`
	License       *string         `json:"license"`
	Compatibility *string         `json:"compatibility"`
	AllowedTools  []string        `json:"allowed_tools"`
	Repository    []byte          `json:"repository"`
	Icons         []byte          `json:"icons"`
	Metadata      []byte          `json:"metadata"`
	ExtensionMeta []byte          `json:"extension_meta"`
}

func (q *Queries) InsertSkillVersion(ctx context.Context, arg InsertSkillVersionParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, insertSkillVersion,
		arg.EntryID,
		arg.Namespace,
		arg.Status,
		arg.License,
		arg.Compatibility,
		arg.AllowedTools,
		arg.Repository,
		arg.Icons,
		arg.Metadata,
		arg.ExtensionMeta,
	)
	var entry_id uuid.UUID
	err := row.Scan(&entry_id)
	return entry_id, err
}

const insertSkillVersionForSync = `-- name: InsertSkillVersionForSync :one
INSERT INTO skill (
    entry_id,
    namespace,
    status,
    license,
    compatibility,
    allowed_tools,
    repository,
    icons,
    metadata,
    extension_meta
) VALUES (
    $1,
    $2,
    COALESCE($3::skill_status, 'ACTIVE'),
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10
)
RETURNING entry_id
`

type InsertSkillVersionForSyncParams struct {
	EntryID       uuid.UUID       `json:"entry_id"`
	Namespace     string          `json:"namespace"`
	Status        NullSkillStatus `json:"status"`
	License       *string         `json:"license"`
	Compatibility *string         `json:"compatibility"`
	AllowedTools  []string        `json:"allowed_tools"`
	Repository    []byte          `json:"repository"`
	Icons         []byte          `json:"icons"`
	Metadata      []byte          `json:"metadata"`
	ExtensionMeta []byte          `json:"extension_meta"`
}

func (q *Queries) InsertSkillVersionForSync(ctx context.Context, arg InsertSkillVersionForSyncParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, insertSkillVersionForSync,
		arg.EntryID,
		arg.Namespace,
		arg.Status,
		arg.License,
		arg.Compatibility,
		arg.AllowedTools,
		arg.Repository,
		arg.Icons,
		arg.Metadata,
		arg.ExtensionMeta,
	)
	var entry_id uuid.UUID
	err := row.Scan(&entry_id)
	return entry_id, err
}

const listSkillGitPackages = `-- name: ListSkillGitPackages :many
SELECT p.id,
       p.skill_entry_id,
       p.url,
       p.ref,
       p.commit_sha,
       p.subfolder
  FROM skill_git_package p
  JOIN skill s ON p.skill_entry_id = s.entry_id
 WHERE s.entry_id = ANY($1::UUID[])
`

func (q *Queries) ListSkillGitPackages(ctx context.Context, entryIds []uuid.UUID) ([]SkillGitPackage, error) {
	rows, err := q.db.Query(ctx, listSkillGitPackages, entryIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SkillGitPackage{}
	for rows.Next() {
		var i SkillGitPackage
		if err := rows.Scan(
			&i.ID,
			&i.SkillEntryID,
			&i.Url,
			&i.Ref,
			&i.CommitSha,
			&i.Subfolder,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSkillOciPackages = `-- name: ListSkillOciPackages :many
SELECT p.id,
       p.skill_entry_id,
       p.identifier,
       p.digest,
       p.media_type
  FROM skill_oci_package p
  JOIN skill s ON p.skill_entry_id = s.entry_id
 WHERE s.entry_id = ANY($1::UUID[])
`

func (q *Queries) ListSkillOciPackages(ctx context.Context, entryIds []uuid.UUID) ([]SkillOciPackage, error) {
	rows, err := q.db.Query(ctx, listSkillOciPackages, entryIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SkillOciPackage{}
	for rows.Next() {
		var i SkillOciPackage
		if err := rows.Scan(
			&i.ID,
			&i.SkillEntryID,
			&i.Identifier,
			&i.Digest,
			&i.MediaType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSkills = `-- name: ListSkills :many
SELECT r.reg_type AS registry_type,
       s.entry_id,
       e.name,
       e.version,
       (l.latest_entry_id IS NOT NULL)::boolean AS is_latest,
       e.created_at,
       e.updated_at,
       e.description,
       e.title,
       s.namespace,
       s.status,
       s.license,
       s.compatibility,
       s.allowed_tools,
       s.repository,
       s.icons,
       s.metadata,
       s.extension_meta
  FROM skill s
  JOIN registry_entry e ON s.entry_id = e.id
  JOIN registry r ON e.reg_id = r.id
  LEFT JOIN latest_entry_version l ON e.id = l.latest_entry_id
 WHERE ($1::text IS NULL OR r.name = $1::text)
   AND ($2::text IS NULL OR s.namespace = $2::text)
   AND ($3::text IS NULL OR e.name = $3::text)
   AND ($4::text IS NULL OR (
       LOWER(e.name) LIKE LOWER('%' || $4::text || '%')
       OR LOWER(e.title) LIKE LOWER('%' || $4::text || '%')
       OR LOWER(e.description) LIKE LOWER('%' || $4::text || '%')
   ))
   AND ($5::timestamp with time zone IS NULL OR e.updated_at > $5::timestamp with time zone)
   AND (
       $6::text IS NULL
       OR (e.name, e.version) > ($6::text, $7::text)
   )
 ORDER BY e.name ASC, e.version ASC
 LIMIT $8::bigint
`

type ListSkillsParams struct {
	RegistryName  *string    `json:"registry_name"`
	Namespace     *string    `json:"namespace"`
	Name          *string    `json:"name"`
	Search        *string    `json:"search"`
	UpdatedSince  *time.Time `json:"updated_since"`
	CursorName    *string    `json:"cursor_name"`
	CursorVersion *string    `json:"cursor_version"`
	Size          int64      `json:"size"`
}

type ListSkillsRow struct {
	RegistryType  RegistryType `json:"registry_type"`
	EntryID       uuid.UUID    `json:"entry_id"`
	Name          string       `json:"name"`
	Version       string       `json:"version"`
	IsLatest      bool         `json:"is_latest"`
	CreatedAt     *time.Time   `json:"created_at"`
	UpdatedAt     *time.Time   `json:"updated_at"`
	Description   *string      `json:"description"`
	Title         *string      `json:"title"`
	Namespace     string       `json:"namespace"`
	Status        SkillStatus  `json:"status"`
	License       *string      `json:"license"`
	Compatibility *string      `json:"compatibility"`
	AllowedTools  []string     `json:"allowed_tools"`
	Repository    []byte       `json:"repository"`
	Icons         []byte       `json:"icons"`
	Metadata      []byte       `json:"metadata"`
	ExtensionMeta []byte       `json:"extension_meta"`
}

// Cursor-based pagination using (name, version) compound cursor.
// The cursor_name and cursor_version parameters define the starting point.
// When cursor is provided, results start AFTER the specified (name, version) tuple.
func (q *Queries) ListSkills(ctx context.Context, arg ListSkillsParams) ([]ListSkillsRow, error) {
	rows, err := q.db.Query(ctx, listSkills,
		arg.RegistryName,
		arg.Namespace,
		arg.Name,
		arg.Search,
		arg.UpdatedSince,
		arg.CursorName,
		arg.CursorVersion,
		arg.Size,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListSkillsRow{}
	for rows.Next() {
		var i ListSkillsRow
		if err := rows.Scan(
			&i.RegistryType,
			&i.EntryID,
			&i.Name,
			&i.Version,
			&i.IsLatest,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Description,
			&i.Title,
			&i.Namespace,
			&i.Status,
			&i.License,
			&i.Compatibility,
			&i.AllowedTools,
			&i.Repository,
			&i.Icons,
			&i.Metadata,
			&i.ExtensionMeta,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertLatestSkillVersion = `-- name: UpsertLatestSkillVersion :one
INSERT INTO latest_entry_version (
    reg_id,
    name,
    version,
    latest_entry_id
) VALUES (
    $1,
    $2,
    $3,
    $4
) ON CONFLICT (reg_id, name)
  DO UPDATE SET
    version = $3,
    latest_entry_id = $4
RETURNING latest_entry_id
`

type UpsertLatestSkillVersionParams struct {
	RegID   uuid.UUID `json:"reg_id"`
	Name    string    `json:"name"`
	Version string    `json:"version"`
	EntryID uuid.UUID `json:"entry_id"`
}

func (q *Queries) UpsertLatestSkillVersion(ctx context.Context, arg UpsertLatestSkillVersionParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, upsertLatestSkillVersion,
		arg.RegID,
		arg.Name,
		arg.Version,
		arg.EntryID,
	)
	var latest_entry_id uuid.UUID
	err := row.Scan(&latest_entry_id)
	return latest_entry_id, err
}

const upsertSkillVersionForSync = `-- name: UpsertSkillVersionForSync :one
INSERT INTO skill (
    entry_id,
    namespace,
    status,
    license,
    compatibility,
    allowed_tools,
    repository,
    icons,
    metadata,
    extension_meta
) VALUES (
    $1,
    $2,
    COALESCE($3::skill_status, 'ACTIVE'),
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10
)
ON CONFLICT (entry_id)
DO UPDATE SET
    status = COALESCE($3::skill_status, skill.status),
    license = $4,
    compatibility = $5,
    allowed_tools = $6,
    repository = $7,
    icons = $8,
    metadata = $9,
    extension_meta = $10
RETURNING entry_id
`

type UpsertSkillVersionForSyncParams struct {
	EntryID       uuid.UUID       `json:"entry_id"`
	Namespace     string          `json:"namespace"`
	Status        NullSkillStatus `json:"status"`
	License       *string         `json:"license"`
	Compatibility *string         `json:"compatibility"`
	AllowedTools  []string        `json:"allowed_tools"`
	Repository    []byte          `json:"repository"`
	Icons         []byte          `json:"icons"`
	Metadata      []byte          `json:"metadata"`
	ExtensionMeta []byte          `json:"extension_meta"`
}

func (q *Queries) UpsertSkillVersionForSync(ctx context.Context, arg UpsertSkillVersionForSyncParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, upsertSkillVersionForSync,
		arg.EntryID,
		arg.Namespace,
		arg.Status,
		arg.License,
		arg.Compatibility,
		arg.AllowedTools,
		arg.Repository,
		arg.Icons,
		arg.Metadata,
		arg.ExtensionMeta,
	)
	var entry_id uuid.UUID
	err := row.Scan(&entry_id)
	return entry_id, err
}
