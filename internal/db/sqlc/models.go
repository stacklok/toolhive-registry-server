// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package sqlc

import (
	"database/sql/driver"
	"fmt"

	"github.com/jackc/pgx/v5/pgtype"
)

type IconTheme string

const (
	IconThemeLIGHT IconTheme = "LIGHT"
	IconThemeDARK  IconTheme = "DARK"
)

func (e *IconTheme) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = IconTheme(s)
	case string:
		*e = IconTheme(s)
	default:
		return fmt.Errorf("unsupported scan type for IconTheme: %T", src)
	}
	return nil
}

type NullIconTheme struct {
	IconTheme IconTheme `json:"icon_theme"`
	Valid     bool      `json:"valid"` // Valid is true if IconTheme is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullIconTheme) Scan(value interface{}) error {
	if value == nil {
		ns.IconTheme, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.IconTheme.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullIconTheme) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.IconTheme), nil
}

type RegistryType string

const (
	RegistryTypeLOCAL  RegistryType = "LOCAL"
	RegistryTypeFILE   RegistryType = "FILE"
	RegistryTypeREMOTE RegistryType = "REMOTE"
)

func (e *RegistryType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = RegistryType(s)
	case string:
		*e = RegistryType(s)
	default:
		return fmt.Errorf("unsupported scan type for RegistryType: %T", src)
	}
	return nil
}

type NullRegistryType struct {
	RegistryType RegistryType `json:"registry_type"`
	Valid        bool         `json:"valid"` // Valid is true if RegistryType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullRegistryType) Scan(value interface{}) error {
	if value == nil {
		ns.RegistryType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.RegistryType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullRegistryType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.RegistryType), nil
}

type SyncStatus string

const (
	SyncStatusINPROGRESS SyncStatus = "IN_PROGRESS"
	SyncStatusCOMPLETED  SyncStatus = "COMPLETED"
	SyncStatusFAILED     SyncStatus = "FAILED"
)

func (e *SyncStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = SyncStatus(s)
	case string:
		*e = SyncStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for SyncStatus: %T", src)
	}
	return nil
}

type NullSyncStatus struct {
	SyncStatus SyncStatus `json:"sync_status"`
	Valid      bool       `json:"valid"` // Valid is true if SyncStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullSyncStatus) Scan(value interface{}) error {
	if value == nil {
		ns.SyncStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.SyncStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullSyncStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.SyncStatus), nil
}

type LatestServerVersion struct {
	RegID          pgtype.UUID `json:"reg_id"`
	Name           string      `json:"name"`
	Version        string      `json:"version"`
	LatestServerID pgtype.UUID `json:"latest_server_id"`
}

type McpServer struct {
	ID                  pgtype.UUID `json:"id"`
	Name                string      `json:"name"`
	Version             string      `json:"version"`
	RegID               pgtype.UUID `json:"reg_id"`
	CreatedAt           interface{} `json:"created_at"`
	UpdatedAt           interface{} `json:"updated_at"`
	Description         pgtype.Text `json:"description"`
	Title               pgtype.Text `json:"title"`
	Website             pgtype.Text `json:"website"`
	UpstreamMeta        []byte      `json:"upstream_meta"`
	ServerMeta          []byte      `json:"server_meta"`
	RepositoryUrl       pgtype.Text `json:"repository_url"`
	RepositoryID        pgtype.Text `json:"repository_id"`
	RepositorySubfolder pgtype.Text `json:"repository_subfolder"`
	RepositoryType      pgtype.Text `json:"repository_type"`
}

type McpServerIcon struct {
	ServerID  pgtype.UUID `json:"server_id"`
	SourceUri string      `json:"source_uri"`
	MimeType  string      `json:"mime_type"`
	Theme     IconTheme   `json:"theme"`
}

type McpServerPackage struct {
	ServerID         pgtype.UUID `json:"server_id"`
	RegistryType     string      `json:"registry_type"`
	PkgRegistryUrl   string      `json:"pkg_registry_url"`
	PkgIdentifier    string      `json:"pkg_identifier"`
	PkgVersion       string      `json:"pkg_version"`
	RuntimeHint      pgtype.Text `json:"runtime_hint"`
	RuntimeArguments []string    `json:"runtime_arguments"`
	PackageArguments []string    `json:"package_arguments"`
	EnvVars          []string    `json:"env_vars"`
	Sha256Hash       pgtype.Text `json:"sha256_hash"`
	Transport        string      `json:"transport"`
	TransportUrl     pgtype.Text `json:"transport_url"`
	TransportHeaders []string    `json:"transport_headers"`
}

type McpServerRemote struct {
	ServerID         pgtype.UUID `json:"server_id"`
	Transport        string      `json:"transport"`
	TransportUrl     string      `json:"transport_url"`
	TransportHeaders []string    `json:"transport_headers"`
}

type Registry struct {
	ID        pgtype.UUID  `json:"id"`
	Name      string       `json:"name"`
	RegType   RegistryType `json:"reg_type"`
	CreatedAt interface{}  `json:"created_at"`
	UpdatedAt interface{}  `json:"updated_at"`
}

type RegistrySync struct {
	ID         pgtype.UUID `json:"id"`
	RegID      pgtype.UUID `json:"reg_id"`
	SyncStatus SyncStatus  `json:"sync_status"`
	ErrorMsg   pgtype.Text `json:"error_msg"`
	StartedAt  interface{} `json:"started_at"`
	EndedAt    interface{} `json:"ended_at"`
}
