// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package sqlc

import (
	"database/sql/driver"
	"fmt"
	"time"

	"github.com/google/uuid"
	"github.com/stacklok/toolhive-registry-server/internal/db/pgtypes"
)

type CreationType string

const (
	CreationTypeAPI    CreationType = "API"
	CreationTypeCONFIG CreationType = "CONFIG"
)

func (e *CreationType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = CreationType(s)
	case string:
		*e = CreationType(s)
	default:
		return fmt.Errorf("unsupported scan type for CreationType: %T", src)
	}
	return nil
}

type NullCreationType struct {
	CreationType CreationType `json:"creation_type"`
	Valid        bool         `json:"valid"` // Valid is true if CreationType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullCreationType) Scan(value interface{}) error {
	if value == nil {
		ns.CreationType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.CreationType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullCreationType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.CreationType), nil
}

type EntryType string

const (
	EntryTypeMCP   EntryType = "MCP"
	EntryTypeSKILL EntryType = "SKILL"
)

func (e *EntryType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = EntryType(s)
	case string:
		*e = EntryType(s)
	default:
		return fmt.Errorf("unsupported scan type for EntryType: %T", src)
	}
	return nil
}

type NullEntryType struct {
	EntryType EntryType `json:"entry_type"`
	Valid     bool      `json:"valid"` // Valid is true if EntryType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullEntryType) Scan(value interface{}) error {
	if value == nil {
		ns.EntryType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.EntryType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullEntryType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.EntryType), nil
}

type IconTheme string

const (
	IconThemeLIGHT IconTheme = "LIGHT"
	IconThemeDARK  IconTheme = "DARK"
)

func (e *IconTheme) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = IconTheme(s)
	case string:
		*e = IconTheme(s)
	default:
		return fmt.Errorf("unsupported scan type for IconTheme: %T", src)
	}
	return nil
}

type NullIconTheme struct {
	IconTheme IconTheme `json:"icon_theme"`
	Valid     bool      `json:"valid"` // Valid is true if IconTheme is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullIconTheme) Scan(value interface{}) error {
	if value == nil {
		ns.IconTheme, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.IconTheme.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullIconTheme) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.IconTheme), nil
}

type RegistryType string

const (
	RegistryTypeMANAGED    RegistryType = "MANAGED"
	RegistryTypeFILE       RegistryType = "FILE"
	RegistryTypeREMOTE     RegistryType = "REMOTE"
	RegistryTypeKUBERNETES RegistryType = "KUBERNETES"
)

func (e *RegistryType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = RegistryType(s)
	case string:
		*e = RegistryType(s)
	default:
		return fmt.Errorf("unsupported scan type for RegistryType: %T", src)
	}
	return nil
}

type NullRegistryType struct {
	RegistryType RegistryType `json:"registry_type"`
	Valid        bool         `json:"valid"` // Valid is true if RegistryType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullRegistryType) Scan(value interface{}) error {
	if value == nil {
		ns.RegistryType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.RegistryType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullRegistryType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.RegistryType), nil
}

type SkillStatus string

const (
	SkillStatusACTIVE     SkillStatus = "ACTIVE"
	SkillStatusDEPRECATED SkillStatus = "DEPRECATED"
	SkillStatusARCHIVED   SkillStatus = "ARCHIVED"
)

func (e *SkillStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = SkillStatus(s)
	case string:
		*e = SkillStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for SkillStatus: %T", src)
	}
	return nil
}

type NullSkillStatus struct {
	SkillStatus SkillStatus `json:"skill_status"`
	Valid       bool        `json:"valid"` // Valid is true if SkillStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullSkillStatus) Scan(value interface{}) error {
	if value == nil {
		ns.SkillStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.SkillStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullSkillStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.SkillStatus), nil
}

type SyncStatus string

const (
	SyncStatusINPROGRESS SyncStatus = "IN_PROGRESS"
	SyncStatusCOMPLETED  SyncStatus = "COMPLETED"
	SyncStatusFAILED     SyncStatus = "FAILED"
)

func (e *SyncStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = SyncStatus(s)
	case string:
		*e = SyncStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for SyncStatus: %T", src)
	}
	return nil
}

type NullSyncStatus struct {
	SyncStatus SyncStatus `json:"sync_status"`
	Valid      bool       `json:"valid"` // Valid is true if SyncStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullSyncStatus) Scan(value interface{}) error {
	if value == nil {
		ns.SyncStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.SyncStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullSyncStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.SyncStatus), nil
}

type LatestEntryVersion struct {
	RegID         uuid.UUID `json:"reg_id"`
	Name          string    `json:"name"`
	Version       string    `json:"version"`
	LatestEntryID uuid.UUID `json:"latest_entry_id"`
}

type McpServer struct {
	Website             *string   `json:"website"`
	UpstreamMeta        []byte    `json:"upstream_meta"`
	ServerMeta          []byte    `json:"server_meta"`
	RepositoryUrl       *string   `json:"repository_url"`
	RepositoryID        *string   `json:"repository_id"`
	RepositorySubfolder *string   `json:"repository_subfolder"`
	RepositoryType      *string   `json:"repository_type"`
	EntryID             uuid.UUID `json:"entry_id"`
}

type McpServerIcon struct {
	EntryID   uuid.UUID `json:"entry_id"`
	SourceUri string    `json:"source_uri"`
	MimeType  string    `json:"mime_type"`
	Theme     IconTheme `json:"theme"`
}

type McpServerPackage struct {
	EntryID          uuid.UUID `json:"entry_id"`
	RegistryType     string    `json:"registry_type"`
	PkgRegistryUrl   string    `json:"pkg_registry_url"`
	PkgIdentifier    string    `json:"pkg_identifier"`
	PkgVersion       string    `json:"pkg_version"`
	RuntimeHint      *string   `json:"runtime_hint"`
	RuntimeArguments []string  `json:"runtime_arguments"`
	PackageArguments []string  `json:"package_arguments"`
	Sha256Hash       *string   `json:"sha256_hash"`
	Transport        string    `json:"transport"`
	TransportUrl     *string   `json:"transport_url"`
	EnvVars          []byte    `json:"env_vars"`
	TransportHeaders []byte    `json:"transport_headers"`
}

type McpServerRemote struct {
	EntryID          uuid.UUID `json:"entry_id"`
	Transport        string    `json:"transport"`
	TransportUrl     string    `json:"transport_url"`
	TransportHeaders []byte    `json:"transport_headers"`
}

type Registry struct {
	ID           uuid.UUID        `json:"id"`
	Name         string           `json:"name"`
	RegType      RegistryType     `json:"reg_type"`
	CreatedAt    *time.Time       `json:"created_at"`
	UpdatedAt    *time.Time       `json:"updated_at"`
	CreationType CreationType     `json:"creation_type"`
	SyncSchedule pgtypes.Interval `json:"sync_schedule"`
	SourceType   *string          `json:"source_type"`
	Format       *string          `json:"format"`
	SourceConfig []byte           `json:"source_config"`
	FilterConfig []byte           `json:"filter_config"`
	Syncable     bool             `json:"syncable"`
}

type RegistryEntry struct {
	ID          uuid.UUID  `json:"id"`
	RegID       uuid.UUID  `json:"reg_id"`
	EntryType   EntryType  `json:"entry_type"`
	Name        string     `json:"name"`
	Title       *string    `json:"title"`
	Description *string    `json:"description"`
	Version     string     `json:"version"`
	CreatedAt   *time.Time `json:"created_at"`
	UpdatedAt   *time.Time `json:"updated_at"`
}

type RegistrySync struct {
	ID                    uuid.UUID  `json:"id"`
	RegID                 uuid.UUID  `json:"reg_id"`
	SyncStatus            SyncStatus `json:"sync_status"`
	ErrorMsg              *string    `json:"error_msg"`
	StartedAt             *time.Time `json:"started_at"`
	EndedAt               *time.Time `json:"ended_at"`
	AttemptCount          int64      `json:"attempt_count"`
	LastSyncHash          *string    `json:"last_sync_hash"`
	LastAppliedFilterHash *string    `json:"last_applied_filter_hash"`
	ServerCount           int64      `json:"server_count"`
}

type Skill struct {
	EntryID       uuid.UUID   `json:"entry_id"`
	Namespace     string      `json:"namespace"`
	Status        SkillStatus `json:"status"`
	License       *string     `json:"license"`
	Compatibility *string     `json:"compatibility"`
	AllowedTools  []string    `json:"allowed_tools"`
	Repository    []byte      `json:"repository"`
	Icons         []byte      `json:"icons"`
	Metadata      []byte      `json:"metadata"`
	ExtensionMeta []byte      `json:"extension_meta"`
}

type SkillGitPackage struct {
	ID           uuid.UUID `json:"id"`
	SkillEntryID uuid.UUID `json:"skill_entry_id"`
	Url          string    `json:"url"`
	Ref          *string   `json:"ref"`
	CommitSha    *string   `json:"commit_sha"`
	Subfolder    *string   `json:"subfolder"`
}

type SkillOciPackage struct {
	ID           uuid.UUID `json:"id"`
	SkillEntryID uuid.UUID `json:"skill_entry_id"`
	Identifier   string    `json:"identifier"`
	Digest       *string   `json:"digest"`
	MediaType    *string   `json:"media_type"`
}

type TempMcpServer struct {
	EntryID             uuid.UUID `json:"entry_id"`
	Website             *string   `json:"website"`
	UpstreamMeta        []byte    `json:"upstream_meta"`
	ServerMeta          []byte    `json:"server_meta"`
	RepositoryUrl       *string   `json:"repository_url"`
	RepositoryID        *string   `json:"repository_id"`
	RepositorySubfolder *string   `json:"repository_subfolder"`
	RepositoryType      *string   `json:"repository_type"`
}

type TempMcpServerIcon struct {
	ServerID  uuid.UUID `json:"server_id"`
	SourceUri string    `json:"source_uri"`
	MimeType  string    `json:"mime_type"`
	Theme     string    `json:"theme"`
}

type TempMcpServerPackage struct {
	ServerID         uuid.UUID `json:"server_id"`
	RegistryType     string    `json:"registry_type"`
	PkgRegistryUrl   string    `json:"pkg_registry_url"`
	PkgIdentifier    string    `json:"pkg_identifier"`
	PkgVersion       string    `json:"pkg_version"`
	RuntimeHint      *string   `json:"runtime_hint"`
	RuntimeArguments []string  `json:"runtime_arguments"`
	PackageArguments []string  `json:"package_arguments"`
	EnvVars          []string  `json:"env_vars"`
	Sha256Hash       *string   `json:"sha256_hash"`
	Transport        string    `json:"transport"`
	TransportUrl     *string   `json:"transport_url"`
	TransportHeaders []string  `json:"transport_headers"`
}

type TempMcpServerRemote struct {
	ServerID         uuid.UUID `json:"server_id"`
	Transport        string    `json:"transport"`
	TransportUrl     string    `json:"transport_url"`
	TransportHeaders []string  `json:"transport_headers"`
}

type TempRegistryEntry struct {
	ID          uuid.UUID  `json:"id"`
	RegID       uuid.UUID  `json:"reg_id"`
	EntryType   EntryType  `json:"entry_type"`
	Name        string     `json:"name"`
	Title       *string    `json:"title"`
	Description *string    `json:"description"`
	Version     string     `json:"version"`
	CreatedAt   *time.Time `json:"created_at"`
	UpdatedAt   *time.Time `json:"updated_at"`
}

type TempSkill struct {
	EntryID       uuid.UUID   `json:"entry_id"`
	Namespace     string      `json:"namespace"`
	Status        SkillStatus `json:"status"`
	License       *string     `json:"license"`
	Compatibility *string     `json:"compatibility"`
	AllowedTools  []string    `json:"allowed_tools"`
	Repository    []byte      `json:"repository"`
	Icons         []byte      `json:"icons"`
	Metadata      []byte      `json:"metadata"`
	ExtensionMeta []byte      `json:"extension_meta"`
}
