// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package sqlc

import (
	"database/sql/driver"
	"fmt"
	"time"

	"github.com/google/uuid"
	"github.com/stacklok/toolhive-registry-server/internal/db/pgtypes"
)

type CreationType string

const (
	CreationTypeAPI    CreationType = "API"
	CreationTypeCONFIG CreationType = "CONFIG"
)

func (e *CreationType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = CreationType(s)
	case string:
		*e = CreationType(s)
	default:
		return fmt.Errorf("unsupported scan type for CreationType: %T", src)
	}
	return nil
}

type NullCreationType struct {
	CreationType CreationType `json:"creation_type"`
	Valid        bool         `json:"valid"` // Valid is true if CreationType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullCreationType) Scan(value interface{}) error {
	if value == nil {
		ns.CreationType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.CreationType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullCreationType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.CreationType), nil
}

type IconTheme string

const (
	IconThemeLIGHT IconTheme = "LIGHT"
	IconThemeDARK  IconTheme = "DARK"
)

func (e *IconTheme) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = IconTheme(s)
	case string:
		*e = IconTheme(s)
	default:
		return fmt.Errorf("unsupported scan type for IconTheme: %T", src)
	}
	return nil
}

type NullIconTheme struct {
	IconTheme IconTheme `json:"icon_theme"`
	Valid     bool      `json:"valid"` // Valid is true if IconTheme is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullIconTheme) Scan(value interface{}) error {
	if value == nil {
		ns.IconTheme, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.IconTheme.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullIconTheme) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.IconTheme), nil
}

type RegistryType string

const (
	RegistryTypeMANAGED    RegistryType = "MANAGED"
	RegistryTypeFILE       RegistryType = "FILE"
	RegistryTypeREMOTE     RegistryType = "REMOTE"
	RegistryTypeKUBERNETES RegistryType = "KUBERNETES"
)

func (e *RegistryType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = RegistryType(s)
	case string:
		*e = RegistryType(s)
	default:
		return fmt.Errorf("unsupported scan type for RegistryType: %T", src)
	}
	return nil
}

type NullRegistryType struct {
	RegistryType RegistryType `json:"registry_type"`
	Valid        bool         `json:"valid"` // Valid is true if RegistryType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullRegistryType) Scan(value interface{}) error {
	if value == nil {
		ns.RegistryType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.RegistryType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullRegistryType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.RegistryType), nil
}

type SyncStatus string

const (
	SyncStatusINPROGRESS SyncStatus = "IN_PROGRESS"
	SyncStatusCOMPLETED  SyncStatus = "COMPLETED"
	SyncStatusFAILED     SyncStatus = "FAILED"
)

func (e *SyncStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = SyncStatus(s)
	case string:
		*e = SyncStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for SyncStatus: %T", src)
	}
	return nil
}

type NullSyncStatus struct {
	SyncStatus SyncStatus `json:"sync_status"`
	Valid      bool       `json:"valid"` // Valid is true if SyncStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullSyncStatus) Scan(value interface{}) error {
	if value == nil {
		ns.SyncStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.SyncStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullSyncStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.SyncStatus), nil
}

type LatestServerVersion struct {
	RegID          uuid.UUID `json:"reg_id"`
	Name           string    `json:"name"`
	Version        string    `json:"version"`
	LatestServerID uuid.UUID `json:"latest_server_id"`
}

type McpServer struct {
	ID                  uuid.UUID  `json:"id"`
	Name                string     `json:"name"`
	Version             string     `json:"version"`
	RegID               uuid.UUID  `json:"reg_id"`
	CreatedAt           *time.Time `json:"created_at"`
	UpdatedAt           *time.Time `json:"updated_at"`
	Description         *string    `json:"description"`
	Title               *string    `json:"title"`
	Website             *string    `json:"website"`
	UpstreamMeta        []byte     `json:"upstream_meta"`
	ServerMeta          []byte     `json:"server_meta"`
	RepositoryUrl       *string    `json:"repository_url"`
	RepositoryID        *string    `json:"repository_id"`
	RepositorySubfolder *string    `json:"repository_subfolder"`
	RepositoryType      *string    `json:"repository_type"`
}

type McpServerIcon struct {
	ServerID  uuid.UUID `json:"server_id"`
	SourceUri string    `json:"source_uri"`
	MimeType  string    `json:"mime_type"`
	Theme     IconTheme `json:"theme"`
}

type McpServerPackage struct {
	ServerID         uuid.UUID `json:"server_id"`
	RegistryType     string    `json:"registry_type"`
	PkgRegistryUrl   string    `json:"pkg_registry_url"`
	PkgIdentifier    string    `json:"pkg_identifier"`
	PkgVersion       string    `json:"pkg_version"`
	RuntimeHint      *string   `json:"runtime_hint"`
	RuntimeArguments []string  `json:"runtime_arguments"`
	PackageArguments []string  `json:"package_arguments"`
	EnvVars          []string  `json:"env_vars"`
	Sha256Hash       *string   `json:"sha256_hash"`
	Transport        string    `json:"transport"`
	TransportUrl     *string   `json:"transport_url"`
	TransportHeaders []string  `json:"transport_headers"`
}

type McpServerRemote struct {
	ServerID         uuid.UUID `json:"server_id"`
	Transport        string    `json:"transport"`
	TransportUrl     string    `json:"transport_url"`
	TransportHeaders []string  `json:"transport_headers"`
}

type Registry struct {
	ID           uuid.UUID        `json:"id"`
	Name         string           `json:"name"`
	RegType      RegistryType     `json:"reg_type"`
	CreatedAt    *time.Time       `json:"created_at"`
	UpdatedAt    *time.Time       `json:"updated_at"`
	CreationType CreationType     `json:"creation_type"`
	SyncSchedule pgtypes.Interval `json:"sync_schedule"`
	SourceType   *string          `json:"source_type"`
	Format       *string          `json:"format"`
	SourceConfig []byte           `json:"source_config"`
	FilterConfig []byte           `json:"filter_config"`
}

type RegistrySync struct {
	ID                    uuid.UUID  `json:"id"`
	RegID                 uuid.UUID  `json:"reg_id"`
	SyncStatus            SyncStatus `json:"sync_status"`
	ErrorMsg              *string    `json:"error_msg"`
	StartedAt             *time.Time `json:"started_at"`
	EndedAt               *time.Time `json:"ended_at"`
	AttemptCount          int64      `json:"attempt_count"`
	LastSyncHash          *string    `json:"last_sync_hash"`
	LastAppliedFilterHash *string    `json:"last_applied_filter_hash"`
	ServerCount           int64      `json:"server_count"`
}

type TempMcpServer struct {
	Name                string     `json:"name"`
	Version             string     `json:"version"`
	RegID               uuid.UUID  `json:"reg_id"`
	CreatedAt           *time.Time `json:"created_at"`
	UpdatedAt           *time.Time `json:"updated_at"`
	Description         *string    `json:"description"`
	Title               *string    `json:"title"`
	Website             *string    `json:"website"`
	UpstreamMeta        []byte     `json:"upstream_meta"`
	ServerMeta          []byte     `json:"server_meta"`
	RepositoryUrl       *string    `json:"repository_url"`
	RepositoryID        *string    `json:"repository_id"`
	RepositorySubfolder *string    `json:"repository_subfolder"`
	RepositoryType      *string    `json:"repository_type"`
}

type TempMcpServerIcon struct {
	ServerID  uuid.UUID `json:"server_id"`
	SourceUri string    `json:"source_uri"`
	MimeType  string    `json:"mime_type"`
	Theme     string    `json:"theme"`
}

type TempMcpServerPackage struct {
	ServerID         uuid.UUID `json:"server_id"`
	RegistryType     string    `json:"registry_type"`
	PkgRegistryUrl   string    `json:"pkg_registry_url"`
	PkgIdentifier    string    `json:"pkg_identifier"`
	PkgVersion       string    `json:"pkg_version"`
	RuntimeHint      *string   `json:"runtime_hint"`
	RuntimeArguments []string  `json:"runtime_arguments"`
	PackageArguments []string  `json:"package_arguments"`
	EnvVars          []string  `json:"env_vars"`
	Sha256Hash       *string   `json:"sha256_hash"`
	Transport        string    `json:"transport"`
	TransportUrl     *string   `json:"transport_url"`
	TransportHeaders []string  `json:"transport_headers"`
}

type TempMcpServerRemote struct {
	ServerID         uuid.UUID `json:"server_id"`
	Transport        string    `json:"transport"`
	TransportUrl     string    `json:"transport_url"`
	TransportHeaders []string  `json:"transport_headers"`
}
