// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: sync.sql

package sqlc

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/stacklok/toolhive-registry-server/internal/db/pgtypes"
)

const bulkInitializeRegistrySyncs = `-- name: BulkInitializeRegistrySyncs :exec
INSERT INTO registry_sync (
    reg_id,
    sync_status,
    error_msg
)
SELECT
    unnest($1::uuid[]),
    unnest($2::sync_status[]),
    unnest($3::text[])
ON CONFLICT (reg_id) DO NOTHING
`

type BulkInitializeRegistrySyncsParams struct {
	RegIds       []uuid.UUID  `json:"reg_ids"`
	SyncStatuses []SyncStatus `json:"sync_statuses"`
	ErrorMsgs    []string     `json:"error_msgs"`
}

func (q *Queries) BulkInitializeRegistrySyncs(ctx context.Context, arg BulkInitializeRegistrySyncsParams) error {
	_, err := q.db.Exec(ctx, bulkInitializeRegistrySyncs, arg.RegIds, arg.SyncStatuses, arg.ErrorMsgs)
	return err
}

const getRegistrySync = `-- name: GetRegistrySync :one
SELECT id,
       reg_id,
       sync_status,
       error_msg,
       started_at,
       ended_at,
       attempt_count,
       last_sync_hash,
       last_applied_filter_hash,
       server_count
FROM registry_sync
WHERE id = $1
`

func (q *Queries) GetRegistrySync(ctx context.Context, id uuid.UUID) (RegistrySync, error) {
	row := q.db.QueryRow(ctx, getRegistrySync, id)
	var i RegistrySync
	err := row.Scan(
		&i.ID,
		&i.RegID,
		&i.SyncStatus,
		&i.ErrorMsg,
		&i.StartedAt,
		&i.EndedAt,
		&i.AttemptCount,
		&i.LastSyncHash,
		&i.LastAppliedFilterHash,
		&i.ServerCount,
	)
	return i, err
}

const getRegistrySyncByName = `-- name: GetRegistrySyncByName :one
SELECT rs.id,
       rs.reg_id,
       rs.sync_status,
       rs.error_msg,
       rs.started_at,
       rs.ended_at,
       rs.attempt_count,
       rs.last_sync_hash,
       rs.last_applied_filter_hash,
       rs.server_count
FROM registry_sync rs
INNER JOIN registry r ON rs.reg_id = r.id
WHERE r.name = $1
`

func (q *Queries) GetRegistrySyncByName(ctx context.Context, name string) (RegistrySync, error) {
	row := q.db.QueryRow(ctx, getRegistrySyncByName, name)
	var i RegistrySync
	err := row.Scan(
		&i.ID,
		&i.RegID,
		&i.SyncStatus,
		&i.ErrorMsg,
		&i.StartedAt,
		&i.EndedAt,
		&i.AttemptCount,
		&i.LastSyncHash,
		&i.LastAppliedFilterHash,
		&i.ServerCount,
	)
	return i, err
}

const initializeRegistrySync = `-- name: InitializeRegistrySync :exec
INSERT INTO registry_sync (
    reg_id,
    sync_status,
    error_msg
) VALUES (
    (SELECT id FROM registry WHERE name = $1),
    $2,
    $3
)
ON CONFLICT (reg_id) DO NOTHING
`

type InitializeRegistrySyncParams struct {
	Name       string     `json:"name"`
	SyncStatus SyncStatus `json:"sync_status"`
	ErrorMsg   *string    `json:"error_msg"`
}

func (q *Queries) InitializeRegistrySync(ctx context.Context, arg InitializeRegistrySyncParams) error {
	_, err := q.db.Exec(ctx, initializeRegistrySync, arg.Name, arg.SyncStatus, arg.ErrorMsg)
	return err
}

const insertRegistrySync = `-- name: InsertRegistrySync :one
INSERT INTO registry_sync (
    reg_id,
    sync_status,
    error_msg,
    started_at
) VALUES (
    $1,
    $2,
    $3,
    $4
) RETURNING id
`

type InsertRegistrySyncParams struct {
	RegID      uuid.UUID  `json:"reg_id"`
	SyncStatus SyncStatus `json:"sync_status"`
	ErrorMsg   *string    `json:"error_msg"`
	StartedAt  *time.Time `json:"started_at"`
}

func (q *Queries) InsertRegistrySync(ctx context.Context, arg InsertRegistrySyncParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, insertRegistrySync,
		arg.RegID,
		arg.SyncStatus,
		arg.ErrorMsg,
		arg.StartedAt,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const listRegistrySyncs = `-- name: ListRegistrySyncs :many
SELECT r.name,
       rs.id,
       rs.reg_id,
       rs.sync_status,
       rs.error_msg,
       rs.started_at,
       rs.ended_at,
       rs.attempt_count,
       rs.last_sync_hash,
       rs.last_applied_filter_hash,
       rs.server_count,
       r.sync_schedule::interval AS sync_schedule
FROM registry_sync rs
INNER JOIN registry r ON rs.reg_id = r.id
ORDER BY rs.started_at DESC, r.name ASC
`

type ListRegistrySyncsRow struct {
	Name                  string           `json:"name"`
	ID                    uuid.UUID        `json:"id"`
	RegID                 uuid.UUID        `json:"reg_id"`
	SyncStatus            SyncStatus       `json:"sync_status"`
	ErrorMsg              *string          `json:"error_msg"`
	StartedAt             *time.Time       `json:"started_at"`
	EndedAt               *time.Time       `json:"ended_at"`
	AttemptCount          int64            `json:"attempt_count"`
	LastSyncHash          *string          `json:"last_sync_hash"`
	LastAppliedFilterHash *string          `json:"last_applied_filter_hash"`
	ServerCount           int64            `json:"server_count"`
	SyncSchedule          pgtypes.Interval `json:"sync_schedule"`
}

func (q *Queries) ListRegistrySyncs(ctx context.Context) ([]ListRegistrySyncsRow, error) {
	rows, err := q.db.Query(ctx, listRegistrySyncs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListRegistrySyncsRow{}
	for rows.Next() {
		var i ListRegistrySyncsRow
		if err := rows.Scan(
			&i.Name,
			&i.ID,
			&i.RegID,
			&i.SyncStatus,
			&i.ErrorMsg,
			&i.StartedAt,
			&i.EndedAt,
			&i.AttemptCount,
			&i.LastSyncHash,
			&i.LastAppliedFilterHash,
			&i.ServerCount,
			&i.SyncSchedule,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRegistrySyncsByLastUpdate = `-- name: ListRegistrySyncsByLastUpdate :many
SELECT r.name,
       rs.id,
       rs.reg_id,
       rs.sync_status,
       rs.error_msg,
       rs.started_at,
       rs.ended_at,
       rs.attempt_count,
       rs.last_sync_hash,
       rs.last_applied_filter_hash,
       rs.server_count,
       r.sync_schedule::interval AS sync_schedule
FROM registry_sync rs
INNER JOIN registry r ON rs.reg_id = r.id
WHERE r.syncable = true
ORDER BY rs.ended_at ASC NULLS FIRST, r.name ASC
FOR UPDATE OF rs SKIP LOCKED
`

type ListRegistrySyncsByLastUpdateRow struct {
	Name                  string           `json:"name"`
	ID                    uuid.UUID        `json:"id"`
	RegID                 uuid.UUID        `json:"reg_id"`
	SyncStatus            SyncStatus       `json:"sync_status"`
	ErrorMsg              *string          `json:"error_msg"`
	StartedAt             *time.Time       `json:"started_at"`
	EndedAt               *time.Time       `json:"ended_at"`
	AttemptCount          int64            `json:"attempt_count"`
	LastSyncHash          *string          `json:"last_sync_hash"`
	LastAppliedFilterHash *string          `json:"last_applied_filter_hash"`
	ServerCount           int64            `json:"server_count"`
	SyncSchedule          pgtypes.Interval `json:"sync_schedule"`
}

func (q *Queries) ListRegistrySyncsByLastUpdate(ctx context.Context) ([]ListRegistrySyncsByLastUpdateRow, error) {
	rows, err := q.db.Query(ctx, listRegistrySyncsByLastUpdate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListRegistrySyncsByLastUpdateRow{}
	for rows.Next() {
		var i ListRegistrySyncsByLastUpdateRow
		if err := rows.Scan(
			&i.Name,
			&i.ID,
			&i.RegID,
			&i.SyncStatus,
			&i.ErrorMsg,
			&i.StartedAt,
			&i.EndedAt,
			&i.AttemptCount,
			&i.LastSyncHash,
			&i.LastAppliedFilterHash,
			&i.ServerCount,
			&i.SyncSchedule,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRegistrySync = `-- name: UpdateRegistrySync :exec
UPDATE registry_sync SET
    sync_status = $1,
    error_msg = $2,
    ended_at = $3
WHERE id = $4
`

type UpdateRegistrySyncParams struct {
	SyncStatus SyncStatus `json:"sync_status"`
	ErrorMsg   *string    `json:"error_msg"`
	EndedAt    *time.Time `json:"ended_at"`
	ID         uuid.UUID  `json:"id"`
}

func (q *Queries) UpdateRegistrySync(ctx context.Context, arg UpdateRegistrySyncParams) error {
	_, err := q.db.Exec(ctx, updateRegistrySync,
		arg.SyncStatus,
		arg.ErrorMsg,
		arg.EndedAt,
		arg.ID,
	)
	return err
}

const updateRegistrySyncStatusByName = `-- name: UpdateRegistrySyncStatusByName :exec
UPDATE registry_sync
SET sync_status = $1,
    started_at = $2
WHERE reg_id = (SELECT id FROM registry WHERE name = $3)
`

type UpdateRegistrySyncStatusByNameParams struct {
	SyncStatus SyncStatus `json:"sync_status"`
	StartedAt  *time.Time `json:"started_at"`
	Name       string     `json:"name"`
}

func (q *Queries) UpdateRegistrySyncStatusByName(ctx context.Context, arg UpdateRegistrySyncStatusByNameParams) error {
	_, err := q.db.Exec(ctx, updateRegistrySyncStatusByName, arg.SyncStatus, arg.StartedAt, arg.Name)
	return err
}

const upsertRegistrySyncByName = `-- name: UpsertRegistrySyncByName :exec
INSERT INTO registry_sync (
    reg_id,
    sync_status,
    error_msg,
    started_at,
    ended_at,
    attempt_count,
    last_sync_hash,
    last_applied_filter_hash,
    server_count
) VALUES (
    (SELECT id FROM registry WHERE name = $1),
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9
)
ON CONFLICT (reg_id) DO UPDATE SET
    sync_status = EXCLUDED.sync_status,
    error_msg = EXCLUDED.error_msg,
    started_at = EXCLUDED.started_at,
    ended_at = EXCLUDED.ended_at,
    attempt_count = EXCLUDED.attempt_count,
    last_sync_hash = EXCLUDED.last_sync_hash,
    last_applied_filter_hash = EXCLUDED.last_applied_filter_hash,
    server_count = EXCLUDED.server_count
`

type UpsertRegistrySyncByNameParams struct {
	Name                  string     `json:"name"`
	SyncStatus            SyncStatus `json:"sync_status"`
	ErrorMsg              *string    `json:"error_msg"`
	StartedAt             *time.Time `json:"started_at"`
	EndedAt               *time.Time `json:"ended_at"`
	AttemptCount          int64      `json:"attempt_count"`
	LastSyncHash          *string    `json:"last_sync_hash"`
	LastAppliedFilterHash *string    `json:"last_applied_filter_hash"`
	ServerCount           int64      `json:"server_count"`
}

func (q *Queries) UpsertRegistrySyncByName(ctx context.Context, arg UpsertRegistrySyncByNameParams) error {
	_, err := q.db.Exec(ctx, upsertRegistrySyncByName,
		arg.Name,
		arg.SyncStatus,
		arg.ErrorMsg,
		arg.StartedAt,
		arg.EndedAt,
		arg.AttemptCount,
		arg.LastSyncHash,
		arg.LastAppliedFilterHash,
		arg.ServerCount,
	)
	return err
}
